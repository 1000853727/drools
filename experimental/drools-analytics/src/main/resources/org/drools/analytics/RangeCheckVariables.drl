#created on: 7.6.2007
package org.drools.analytics.rangeChecks.variables;

#list any import classes here.
import org.drools.analytics.components.*;
import org.drools.analytics.accumulateFunction.ValidatePattern;
import org.drools.analytics.accumulateFunction.ValidatePatternResult;
import org.drools.analytics.result.AnalysisResult;
import org.drools.analytics.result.Gap;

import java.util.ArrayList;
import java.util.TreeSet;
import java.text.SimpleDateFormat;
import java.util.Locale;

#declare any global variables here
global AnalysisResult result

# If all ranges are not checked for a field.
# 
# Type: Warning
# Example: in "Rule 1" Foo(bar > 42 ) and in "Rule 2" Foo( bar < 42 )
# 					then Foo( bar == 42 ) is missing.
rule "Range check for integers, smaller and greater than"
	when
		$f :Field( fieldType == Field.FieldType.INT, $fieldId :id, $fieldName :name, $classId :classId )
		(
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == ">", 
											$patternIsNot :patternIsNot, $value :intValue )
			and
				not LiteralRestriction( fieldId == $fieldId, ( evaluator == "==" || == "<=" ), 
											patternIsNot == $patternIsNot, intValue == $value )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == "<", 
											$patternIsNot :patternIsNot, $value :intValue )
			and
				not LiteralRestriction( fieldId == $fieldId, ( evaluator == "==" || == ">=" ), 
											patternIsNot == $patternIsNot, intValue == $value )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == "<=", 
											$patternIsNot :patternIsNot, $value :intValue )
			and
				not LiteralRestriction( fieldId == $fieldId, evaluator  == ">", 
											patternIsNot == $patternIsNot, intValue == $value )
			# XXX: Field might be double, then this pattern is useless.
			and
				not LiteralRestriction( fieldId == $fieldId, evaluator  == ">=", 
											patternIsNot == $patternIsNot, eval( intValue == $value + 1 ) )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == ">=", 
											$patternIsNot :patternIsNot, $value :intValue )
			and
				not LiteralRestriction( fieldId == $fieldId, evaluator  == "<", 
											patternIsNot == $patternIsNot, intValue == $value )
			# XXX: Field might be double, then this pattern is useless. 
			and
				not LiteralRestriction( fieldId == $fieldId, evaluator  == "<=", 
											patternIsNot == $patternIsNot, eval( intValue == $value - 1 ) )
		)
		$rule :AnalyticsRule( id == $r.ruleId )
	then
		Gap gap = new Gap();
		gap.setCause($f);
		gap.setRuleName($rule.getRuleName());
		gap.setEvaluator($r.getEvaluator());
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue($value +"");
		insert( gap );
end

# If all ranges are not checked for a field.
# If equality and smaller than exist check that greater than exists too.
#
# Type: Warning
# Example: in "Rule 1" Foo(bar == 42 ) and in "Rule 2" Foo( bar < 42 )
# 					then Foo( bar > 42 ) is missing.
rule "Range check for integers, equal and greater than"
	when
		(
		# Case Foo( bar == 42 ) Foo( bar >= 43 || == 43 ).
				$f :Field( fieldType == Field.FieldType.INT )
			and
				$r :LiteralRestriction( fieldId == $f.id, evaluator == "==" )
			and
				LiteralRestriction( fieldId == $f.id, 
										( evaluator == "==" || == ">=" ),
										patternIsNot == $r.patternIsNot, 
										eval( intValue == $r.getIntValue() + 1 ) )
		) or (
		# Case Foo( bar == 42 ) Foo( bar >= 42 || > 42 ).
				$f :Field( fieldType == Field.FieldType.INT )
			and
				$r :LiteralRestriction( fieldId == $f.id, evaluator == "==" )
			and
				LiteralRestriction( fieldId == $f.id, 
										( evaluator == ">" || == ">=" ), 
										patternIsNot == $r.patternIsNot, 
										intValue == $r.intValue )
		)
		# Check if Foo( bar < 42 || <= 42 ) is missing.
		not	LiteralRestriction( fieldId == $f.id, 
								( evaluator == "<" || == "<=" ), 
								patternIsNot == $r.patternIsNot, 
								intValue == $r.intValue )
		# Check if Foo( bar == 41 || <= 41 ) is missing.
		not	LiteralRestriction( fieldId == $f.id, 
								( evaluator == "==" || == "<=" ), 
								patternIsNot == $r.patternIsNot, 
								eval( intValue == $r.getIntValue() - 1 ) )
		$rule :AnalyticsRule( id == $r.ruleId )
	then
		Gap gap = new Gap();
		gap.setCause($f);
		gap.setRuleName($rule.getRuleName());
		gap.setEvaluator("<");
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue($r.getIntValue() + "");
		insert( gap );
end

# If all ranges are not checked for a field.
# If equality and smaller than exist check that greater than exists too.
#
# Type: Warning
# Example: in "Rule 1" Foo(bar == 42 ) and in "Rule 2" Foo( bar > 42 )
# 					then Foo( bar < 42 ) is missing.
rule "Range check for integers, equal and smaller than"
	when
		(
		# Case Foo( bar == 42 ) Foo( bar <= 43 || == 43 ).
				$f :Field( fieldType == Field.FieldType.INT )
			and
				$r :LiteralRestriction( fieldId == $f.id, evaluator == "==" )
			and
				LiteralRestriction( fieldId == $f.id, 
										( evaluator == "==" || == "<=" ),
										patternIsNot == $r.patternIsNot, 
										eval( intValue == $r.getIntValue() - 1 ) )
		) or (
		# Case Foo( bar == 42 ) Foo( bar <= 42 || < 42 ).
				$f :Field( fieldType == Field.FieldType.INT )
			and
				$r :LiteralRestriction( fieldId == $f.id, evaluator == "==" )
			and
				LiteralRestriction( fieldId == $f.id, 
										( evaluator == "<" || == "<=" ), 
										patternIsNot == $r.patternIsNot, 
										intValue == $r.intValue )
		)
		# Check if Foo( bar > 42 || >= 42 ) is missing.
		not	LiteralRestriction( fieldId == $f.id, 
								( evaluator == ">" || == ">=" ), 
								patternIsNot == $r.patternIsNot, 
								intValue == $r.intValue )
		# Check if Foo( bar == 41 || >= 41 ) is missing.
		not	LiteralRestriction( fieldId == $f.id, 
								( evaluator == "==" || == ">=" ), 
								patternIsNot == $r.patternIsNot, 
								eval( intValue == $r.getIntValue() + 1 ) )
		$rule :AnalyticsRule( id == $r.ruleId )
	then
		Gap gap = new Gap();
		gap.setCause($f);
		gap.setRuleName($rule.getRuleName());
		gap.setEvaluator(">");
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue($r.getIntValue() +"");
		insert( gap );
end
/*
# If all ranges are not checked for a field.
# If equality and greater than exist check that greater than exists too.
#
# Type: Warning
# Example: in "Rule 1" Foo(bar == 42 ) and in "Rule 2" Foo( bar > 42 )
# 					then Foo( bar < 42 ) is missing.
rule "Range check for integers, equal and smaller than"
	when
		$f :Field( fieldType == Field.FieldType.INT, $fieldId :id, $fieldName :name, $classId :classId )
		$r :LiteralRestriction( fieldId == $fieldId, evaluator == "==" )
		(
				LiteralRestriction( fieldId == $fieldId, 
										( evaluator == "==" || == "<=" ), 
										patternIsNot == $r.patternIsNot, 
										eval( intValue == $r.getIntValue() - 1 ) )
			or
				LiteralRestriction( fieldId == $fieldId, 
										( evaluator == "<" || == "<=" ), 
										patternIsNot == $r.patternIsNot, intValue == $r.intValue )
		)
		not	LiteralRestriction( fieldId == $fieldId, 
								( evaluator == "==" || == ">=" ), 
								patternIsNot == $r.patternIsNot, 
								eval( intValue == $r.getIntValue() + 1 ) )
		$rule :AnalyticsRule( id == $r.ruleId )
	then
		Gap gap = new Gap();
		gap.setCause($f);
		gap.setRuleName($rule.getRuleName());
		gap.setEvaluator(">=");
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue($r.getIntValue() +"");
		insert( gap );
end
*/
# If all ranges are not checked for a field.
# 
# Type: Warning
# Example: in "Rule 1" Foo(bar > 42 ) and in "Rule 2" Foo( bar < 42 )
# 					then Foo( bar == 42 ) is missing.
rule "Range check for doubles"
	when
		$f :Field( fieldType == Field.FieldType.DOUBLE, $fieldId :id, $fieldName :name, $classId :classId )
		(
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == ">", 
											$patternIsNot :patternIsNot, $value :doubleValue )
			and
				not LiteralRestriction( fieldId == $fieldId, ( evaluator == "==" || == "<=" ), 
											patternIsNot == $patternIsNot, intValue == $value )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == "<", 
											$patternIsNot :patternIsNot, $value :doubleValue )
			and
				not LiteralRestriction( fieldId == $fieldId, ( evaluator == "==" || == ">=" ), 
											patternIsNot == $patternIsNot, doubleValue == $value )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == "<=", 
											$patternIsNot :patternIsNot, $value :doubleValue )
			and
				not LiteralRestriction( fieldId == $fieldId, evaluator  == ">", 
											patternIsNot == $patternIsNot, doubleValue == $value )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == ">=", 
											$patternIsNot :patternIsNot, $value :doubleValue )
			and
				not LiteralRestriction( fieldId == $fieldId, evaluator  == "<", 
											patternIsNot == $patternIsNot, doubleValue == $value )
		)
		$rule :AnalyticsRule( id == $r.ruleId )
	then
		Gap gap = new Gap();
		gap.setCause($f);
		gap.setRuleName($rule.getRuleName());
		gap.setEvaluator($r.getEvaluator());
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue($value +"");
		insert( gap );
end

# If all ranges are not checked for a date field.
# 
# Type: Warning
# Example: in "Rule 1" Foo( bar < "27-Oct-2007" ) and in "Rule 2" Foo( bar > "27-Oct-2007" )
# 					then Foo( bar == "27-Oct-2007" ) is missing.
rule "Range check for dates"
	when
		$f :Field( fieldType == Field.FieldType.DATE, $fieldId :id, $fieldName :name, $classId :classId )
		(
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == ">", 
											$patternIsNot :patternIsNot, $value :dateValue )
			and
				not LiteralRestriction( fieldId == $fieldId, ( evaluator == "==" || == "<=" ), 
											patternIsNot == $patternIsNot, eval( dateValue.equals($value) ) )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == "<", 
											$patternIsNot :patternIsNot, $value :dateValue )
			and
				not LiteralRestriction( fieldId == $fieldId, ( evaluator == "==" || == ">=" ), 
											patternIsNot == $patternIsNot, eval( dateValue.equals($value) ) )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == "<=", 
											$patternIsNot :patternIsNot, $value :dateValue )
			and
				not LiteralRestriction( fieldId == $fieldId, evaluator == ">", 
											patternIsNot == $patternIsNot, eval( dateValue.equals($value) ) )
		) or (
				$r :LiteralRestriction( fieldId == $fieldId, evaluator == ">=", 
											$patternIsNot :patternIsNot, $value :dateValue )
			and
				not LiteralRestriction( fieldId == $fieldId, evaluator == "<", 
											patternIsNot == $patternIsNot, eval( dateValue.equals($value) ) )
		)
		$rule :AnalyticsRule( id == $r.ruleId )
	then
		String fmt = System.getProperty("drools.dateformat");
		if (fmt == null) {
			fmt = "dd-MMM-yyyy";
		}
		Gap gap = new Gap();
		gap.setCause($f);
		gap.setRuleName($rule.getRuleName());
		gap.setEvaluator($r.getEvaluator());
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue(new SimpleDateFormat(fmt, Locale.ENGLISH).format($value));
		insert( gap );
end

/*
rule "test"
	when
		$o :Object()
	then
		System.out.println($o);
end
*/
/*
# If all ranges are not checked for a field.
# 
# Type: Warning
# Example: in "Rule 1" Something( $value :value ) and Foo( bar > $value ) 
#			and in "Rule 2" Something( $value :value ) and Foo( bar < $value ) 
# 					then Foo( bar == Something.value ) is missing.
rule "Range check for variables when restriction is QualifiedIdentifierRestriction"
	when
		# Find a field that is of type variable.
		$f :Field( fieldType == Field.FieldType.VARIABLE )
		# Find constraint that matches this field
		# Find variable that is on the right side of this constraint i.e. bar > $foo
		# Find another variable that points to the same field. 
		# Find another constraint and check if it continues to check the range for this field.
		(
				$r :QualifiedIdentifierRestriction( fieldId == $f.id, evaluator == ">" )
			and
				$v1 :Variable( id == $r.variableId )
			and
			(
				$v2 :Variable( objectId == $v1.objectId, objectType == $v1.objectType, id != $v1.id)
			) or (
			
			and
				not QualifiedIdentifierRestriction( fieldId == $f.id, ( evaluator == "==" || == "<=" ), 
														variablePath == $r.variablePath, variableId == $v2.id,
														patternIsNot == $r.patternIsNot )
			)
		) or (
				$r :QualifiedIdentifierRestriction( fieldId == $f.id, evaluator == "<" )
			and
				$v1 :Variable( id == $r.variableId )
			and
				$v2 :Variable( objectId == $v1.objectId, objectType == $v1.objectType, id != $v1.id)
			and
				not QualifiedIdentifierRestriction( fieldId == $f.id, ( evaluator == "==" || == ">=" ), 
														variablePath == $r.variablePath, variableId == $v2.id,
														patternIsNot == $r.patternIsNot )
		) or (
				$r :QualifiedIdentifierRestriction( fieldId == $f.id, evaluator == "<=" )
			and
				$v1 :Variable( id == $r.variableId )
			and
				$v2 :Variable( objectId == $v1.objectId, objectType == $v1.objectType, id != $v1.id)
			and
				not QualifiedIdentifierRestriction( fieldId == $f.id, evaluator == ">", 
														variablePath == $r.variablePath, variableId == $v2.id,
														patternIsNot == $r.patternIsNot )
		) or (
				$r :QualifiedIdentifierRestriction( fieldId == $f.id, evaluator == ">=" )
			and
				$v1 :Variable( id == $r.variableId )
			and
				$v2 :Variable( objectId == $v1.objectId, objectType == $v1.objectType, id != $v1.id)
			and
				not QualifiedIdentifierRestriction( fieldId == $f.id, evaluator == "<", 
														variablePath == $r.variablePath, variableId == $v2.id,
														patternIsNot == $r.patternIsNot )
		)
		$rule :AnalyticsRule( id == $r.ruleId )
	then
		Gap gap = new Gap();
		gap.setCause($f);
		gap.setRuleName($rule.getRuleName());
		gap.setEvaluator($r.getEvaluator());
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue("variable");
		insert( gap );
		
		#if(testTool != null){
		#	testTool.getRulesThatHadErrors().add($rule.getRuleName());
		#}
end 

# If all ranges are not checked for a field.
# 
# Type: Warning
# Example: in "Rule 1" Something( $value :value ) and Foo( bar > $value ) 
#			and in "Rule 2" Something( $value :value ) and Foo( bar < $value ) 
# 					then Foo( bar == Something.value ) is missing.
rule "Range check for variables when restriction is VariableRestriction"
	when
		# Find a field that is of type variable.
		$f :Field( fieldType == Field.FieldType.VARIABLE )
		# Find constraint that matches this field
		# Find variable that is on the right side of this constraint i.e. bar > $foo
		# Find another variable that points to the same field. 
		# Find another constraint and check if it continues to check the range for this field.
		(
				$r :VariableRestriction( fieldId == $f.id, evaluator == ">" )
			and
				$v1 :Variable( id == $r.variableId )
			and
				$v2 :Variable( objectId == $v1.objectId, objectType == $v1.objectType, id != $v1.id)
			and
				not VariableRestriction( fieldId == $f.id, ( evaluator == "==" || == "<=" ), 
														variableId == $v2.id,
														patternIsNot == $r.patternIsNot )
		) or (
				$r :VariableRestriction( fieldId == $f.id, evaluator == "<" )
			and
				$v1 :Variable( id == $r.variableId )
			and
				$v2 :Variable( objectId == $v1.objectId, objectType == $v1.objectType, id != $v1.id)
			and
				not VariableRestriction( fieldId == $f.id, ( evaluator == "==" || == ">=" ), 
														variableId == $v2.id,
														patternIsNot == $r.patternIsNot )
		) or (
				$r :VariableRestriction( fieldId == $f.id, evaluator == "<=" )
			and
				$v1 :Variable( id == $r.variableId )
			and
				$v2 :Variable( objectId == $v1.objectId, objectType == $v1.objectType, id != $v1.id)
			and
				not VariableRestriction( fieldId == $f.id, evaluator == ">", 
														variableId == $v2.id,
														patternIsNot == $r.patternIsNot )
		) or (
				$r :VariableRestriction( fieldId == $f.id, evaluator == ">=" )
			and
				$v1 :Variable( id == $r.variableId )
			and
				$v2 :Variable( objectId == $v1.objectId, objectType == $v1.objectType, id != $v1.id)
			and
				not VariableRestriction( fieldId == $f.id, evaluator == "<", 
														variableId == $v2.id,
														patternIsNot == $r.patternIsNot )
		)
		$rule :AnalyticsRule( id == $r.ruleId )
	then
		Gap gap = new Gap();
		gap.setCause($f);
		gap.setRuleName($rule.getRuleName());
		gap.setEvaluator($r.getEvaluator());
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue("variable");
		insert( gap );
end 
*/
# If all pattern ranges are not checked for a field.
# 
# Type: Warning
# Example: in "Rule 1" Foo( bar == 10 ) and in "Rule 2" Foo( bar == 20 ) and in "Rule 3" Foo( bar == 40 )
# 					then Foo( bar == 30 ) is missing.
rule "Range check for number patterns"
	when
		$f :Field( ( fieldType == Field.FieldType.INT || == Field.FieldType.DOUBLE ), 
					$fieldId :id, $fieldName :name, $classId :classId )
		AnalyticsClass( id == $classId, $className :name )
		(
			# Where pattern is false.
			$validationResult :ValidatePatternResult( value != null)
				from accumulate(
					$r :LiteralRestriction( fieldId == $fieldId, 
						patternIsNot == false, ( evaluator == "==" || == "!=" )),
					validatePattern( $r )
				)
		) or (
			# Where pattern is true.
			$validationResult :ValidatePatternResult( value != null)
				from accumulate(
					$r :LiteralRestriction( fieldId == $fieldId, 
						patternIsNot == true, ( evaluator == "==" || == "!=" )),
					validatePattern( $r )
				)
		)
	then
		// TODO: Find out if evaluator is == or !=.
		Gap gap = new Gap();
		gap.setCause($f);
		#gap.setRuleName($rule.getRuleName());
		#gap.setEvaluator($r.getEvaluator());
		gap.setFiredRuleName(drools.getRule().getName());
		gap.setValue($validationResult.toString());
		insert( gap );
end
