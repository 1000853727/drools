#created on: 7.6.2007
package org.drools.analytics

#list any import classes here.
import org.drools.analytics.components.*;
import org.drools.analytics.result.*;

import java.text.SimpleDateFormat;
import java.util.ArrayList;

#declare any global variables here
global AnalysisResult result


# TODO: And from and every object.
//TODO: Also check that patterns and rules are redundant.
/*
rule "Find redundant ReturnValueRestriction"
	when
		# Check that Restrictions $left and $right have redundant fields.
		$left :ReturnValueRestriction()
		$right :ReturnValueRestriction( 
			id != $left.id,
			evaluator == $left.evaluator,
			classMethodName matches $left.classMethodName,
			compareStringArrays( declarations, $left.declarations )
		)
					
		# Check that PatternPossibilities $pp1 and $pp2 have redundant fields
		# and that they contain $left and $right.
		$pp1 :PatternPossibility( restriction contains $left ) 
		$pp2 :PatternPossibility( 
					id != $pp1.id, 
					restriction contains $right, 
					exist == $pp1.exist, 
					notExist == $pp1.notExist,
					eval( restrictions.size() == $pp1.getRestrictions().size() ) 
		)
		# Check that there is not allready a pair with these values.
		not RedundantPair( left == $left, right == $right )
	then
		insert( new RedundantPair( $pp1, $pp2, $left, $right ) );
end
*/
rule "Find redundant VariableRestriction"
	when
		# Check that Restrictions $left and $right have redundant fields.
		$left :VariableRestriction()
		$right :VariableRestriction( 
			id != $left.id, 
			evaluator == $left.evaluator 
		)
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
		
		# Check that these two variables point to the same object.
		$v :Variable( id == $left.variableId )
		Variable( 
			id == $right.variableId,
			objectType == $v.objectType,
			objectId == $v.objectId
		)
	then
		insert( new Redundancy( $left, $right ) );
end

/*
XXX: Not sure if this can be done.
rule "Find redundant QualifiedIdentifierRestriction"
	when
		# Check that Restrictions $left and $right have redundant fields.
		$left :QualifiedIdentifierRestriction()
		$right :QualifiedIdentifierRestriction( 
			id != $left.id, 
			evaluator == $left.evaluator 
		)
		
		# Check that these two variables point to the same object.
		$v :Variable( id == $left.variableId )
		Variable( 
			id == $right.variableId,
			objectType == $v.objectType,
			objectId == $v.objectId
		)
		
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
		not Redundancy( 
			left == $right, 
			right == $left 
		)
	then
		insert( new Redundancy( $left, $right ) );
end
*/


rule "Find redundant LiteralRestriction"
	when
		# Check that Restrictions $left and $right have redundant fields.
		$left :LiteralRestriction()
		and
		(
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.BOOLEAN,
					booleanValue == $left.booleanValue
				)
			or
				$right :LiteralRestriction( id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.STRING,
					stringValue matches $left.stringValue
				)
			or
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.INT,
					intValue == $left.intValue
				)
			or
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.DOUBLE,
					doubleValue == $left.doubleValue
				)
			or
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.DATE,
					eval( dateValue.equals($left.getDateValue()) )
				)
			or
			(
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.VARIABLE
				)
				and
					$v :Variable( 
						objectType == AnalyticsComponentType.FIELD,
						objectId == $left.id
					)
				and
					Variable( 
						objectType == AnalyticsComponentType.FIELD,
						objectId == $right.id,
						objectName == $v.objectName,
						name == $v.name
					)
			)
		)
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
	then
		insert( new Redundancy( $left, $right ) );
end


#
# Only checks for redundant pattern specifications, 
# does not include actual restriction checks.
#
rule "Find redundant Pattern shells"
	when
		# Check that Patterns $left and $right have redundant fields.
		$left :Pattern()
		$right :Pattern( 
			id != $left.id, 
	  		classId == $left.classId,
	  		# TODO: In some cases the source might be redundant with different sources.
	 		sourceType == $left.sourceType, 
	  		sourceId == $left.sourceId,
	  		patternNot == $left.patternNot,
	  		patternExists == $left.patternExists,
	  		patternForall == $left.patternForall
		)
		
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
	then
		insert( new Redundancy( $left, $right ) );
end

#
# Only checks for redundant rule specifications, 
# does not include actual pattern and restriction checks.
#
rule "Find redundant Rule shells"
	when
		# Check that AnalyticsRule $left and $right have redundant fields.
		$left :AnalyticsRule()
		$right :AnalyticsRule( 
			id != $left.id, 
			ruleSalience == $left.ruleSalience,
			ruleAgendaGroup == $left.ruleAgendaGroup,
			consequence == $left.consequence # TODO: Check for redundancy when MVEL is solved.
		)
		
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
	then
		insert( new Redundancy( $left, $right ) );
end


rule "Find part of redundant PatternPossibility combination"
	when
		# Restriction Redundancy.
		$redundancy :Redundancy()
		
		# Check that patterns are redundant.
		$p1 :Pattern()
		$p2 :Pattern( id != $p1.id )
		Redundancy( 
			left == $p1, 
			right == $p2 
		)
		
		# Find two PatternPossibilities.
		$pp1 :PatternPossibility( 
			patternId == $p1.id, 
			items contains $redundancy.left 
		)
		$pp2 :PatternPossibility( 
			patternId == $p2.id, 
			items contains $redundancy.right 
		)
	then
		insert( new PartialRedundancy( $pp1, $pp2, $redundancy ) );
end


rule "Find part of redundant RulePossibility combination"
	when
		# PatternPossibility Redundancy.
		$redundancy :Redundancy()
		
		# Check that rules are redundant.
		$r1 :AnalyticsRule()
		$r2 :AnalyticsRule( id != $r1.id )
		Redundancy( 
			left == $r1, 
			right == $r2 
		)
		
		# Find two RulePossibilities.
		$rp1 :RulePossibility( 
			ruleId == $r1.id,
			items contains $redundancy.left 
		)
		$rp2 :RulePossibility( 
			ruleId == $r2.id, 
			items contains $redundancy.right 
		)
	then
		insert( new PartialRedundancy( $rp1, $rp2, $redundancy ) );
end

/*
#
# Handles both RulePossibilities and PatternPossibilities.
#
rule "Find subsumptant Possibilities"
	when
		$pp1 :Possibility()
		$pp2 :Possibility( id != $pp1.id )
		
		# Count that there is as many redundant items as there is PartialRedundancies.
		Number( intValue == $pp1.items.size )
			from accumulate(
				$pr :PartialRedundancy( 
					left == $pp1, 
					right == $pp2 
				), 
				count( $pr )
			)
	then
		insert( new Subsumption( $pp1, $pp2 ) );
end


#
# Checks for all PartialRedundancys that contain either PatternPossibilities
# or RulePossibilities.
#
rule "Find redundant PartialRedundancies"
	when
		# If both sides are in subsumption with each other, 
		# then they are also redundant.
		$pr :PartialRedundancy()
		PartialRedundancy( 
			leftParent == $pr.rightParent, 
			rightParent == $pr.leftParent 
		)
	then
		insert( new Redundancy( $pr.leftParent, $pr.rightParent ) );
end


# TODO: Partial redundancy, when some two rulepossibilities from different rules 
# are redundant. but not all of the possibilities are redundant!
# NOTE: Write this one to to out put rules.

*/

















