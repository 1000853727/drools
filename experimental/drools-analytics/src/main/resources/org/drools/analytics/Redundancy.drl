#created on: 7.6.2007
package org.drools.analytics

#list any import classes here.
import org.drools.analytics.components.*;
import org.drools.analytics.result.*;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashSet;

#declare any global variables here
global AnalysisResult result


# TODO: And from and every object.
//TODO: Also check that patterns and rules are redundant.
/*
rule "Find redundant ReturnValueRestriction"
	when
		# Check that Restrictions $left and $right have redundant fields.
		$left :ReturnValueRestriction()
		$right :ReturnValueRestriction( 
			id != $left.id,
			evaluator == $left.evaluator,
			classMethodName matches $left.classMethodName,
			compareStringArrays( declarations, $left.declarations )
		)
					
		# Check that PatternPossibilities $pp1 and $pp2 have redundant fields
		# and that they contain $left and $right.
		$pp1 :PatternPossibility( restriction contains $left ) 
		$pp2 :PatternPossibility( 
					id != $pp1.id, 
					restriction contains $right, 
					exist == $pp1.exist, 
					notExist == $pp1.notExist,
					eval( restrictions.size() == $pp1.getRestrictions().size() ) 
		)
		# Check that there is not allready a pair with these values.
		not RedundantPair( left == $left, right == $right )
	then
		insert( new RedundantPair( $pp1, $pp2, $left, $right ) );
end
*/
rule "Find redundant VariableRestriction"
	when
		# Check that Restrictions $left and $right have redundant fields.
		$left :VariableRestriction()
		$right :VariableRestriction( 
			id != $left.id, 
			evaluator == $left.evaluator 
		)
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
		
		# Check that these two variables point to the same object.
		$v :Variable( id == $left.variableId )
		Variable( 
			id == $right.variableId,
			objectType == $v.objectType,
			objectId == $v.objectId
		)
	then
		insert( new Redundancy( Redundancy.Type.STRONG, $left, $right ) );
end

/*
XXX: Not sure if this can be done.
rule "Find redundant QualifiedIdentifierRestriction"
	when
		# Check that Restrictions $left and $right have redundant fields.
		$left :QualifiedIdentifierRestriction()
		$right :QualifiedIdentifierRestriction( 
			id != $left.id, 
			evaluator == $left.evaluator 
		)
		
		# Check that these two variables point to the same object.
		$v :Variable( id == $left.variableId )
		Variable( 
			id == $right.variableId,
			objectType == $v.objectType,
			objectId == $v.objectId
		)
		
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
		not Redundancy( 
			left == $right, 
			right == $left 
		)
	then
		insert( new Redundancy( $left, $right ) );
end
*/


rule "Find redundant LiteralRestriction"
	when
		# Check that Restrictions $left and $right have redundant fields.
		$left :LiteralRestriction()
		and
		(
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.BOOLEAN,
					booleanValue == $left.booleanValue
				)
			or
				$right :LiteralRestriction( id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.STRING,
					stringValue matches $left.stringValue
				)
			or
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.INT,
					intValue == $left.intValue
				)
			or
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.DOUBLE,
					doubleValue == $left.doubleValue
				)
			or
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.DATE,
					eval( dateValue.equals($left.getDateValue()) )
				)
			or
			(
				$right :LiteralRestriction( 
					id != $left.id, 
					evaluator == $left.evaluator,
					valueType == Field.FieldType.VARIABLE
				)
				and
					$v :Variable( 
						objectType == AnalyticsComponentType.FIELD,
						objectId == $left.id
					)
				and
					Variable( 
						objectType == AnalyticsComponentType.FIELD,
						objectId == $right.id,
						objectName == $v.objectName,
						name == $v.name
					)
			)
		)
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
	then
		insert( new Redundancy( Redundancy.Type.STRONG, $left, $right ) );
end


#
# Only checks for redundant pattern specifications, 
# does not include actual restriction checks.
#
rule "Find redundant Pattern shells"
	when
		# Check that Patterns $left and $right have redundant fields.
		$left :Pattern()
		$right :Pattern( 
			id != $left.id, 
	  		classId == $left.classId,
	  		# TODO: In some cases the source might be redundant with different sources.
	 		sourceType == $left.sourceType, 
	  		sourceId == $left.sourceId,
	  		patternNot == $left.patternNot,
	  		patternExists == $left.patternExists,
	  		patternForall == $left.patternForall
		)
		
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
	then
		insert( new Redundancy( Redundancy.Type.WEAK, $left, $right ) );
end

#
# Only checks for redundant rule specifications, 
# does not include actual pattern and restriction checks.
#
rule "Find redundant Rule shells"
	when
		# Check that AnalyticsRule $left and $right have redundant fields.
		$left :AnalyticsRule()
		$right :AnalyticsRule( 
			id != $left.id, 
			ruleSalience == $left.ruleSalience,
			ruleAgendaGroup == $left.ruleAgendaGroup,
			consequence == $left.consequence # TODO: Check for redundancy when MVEL is solved.
		)
		
		# Check that there is not already a pair with these values.
		not Redundancy( 
			left == $left, 
			right == $right 
		)
	then
		insert( new Redundancy( Redundancy.Type.WEAK, $left, $right ) );
end


rule "Find part of redundant PatternPossibility combination"
	when
		# Restriction Redundancy.
		$redundancy :Redundancy()
		
		# Check that patterns are redundant.
		$p1 :Pattern()
		$p2 :Pattern( id != $p1.id )
		Redundancy( 
			left == $p1, 
			right == $p2 
		)
		
		# Find two PatternPossibilities.
		$pp1 :PatternPossibility( 
			patternId == $p1.id, 
			items contains $redundancy.left 
		)
		$pp2 :PatternPossibility( 
			patternId == $p2.id, 
			items contains $redundancy.right 
		)
	then
		insert( new PartialRedundancy( $pp1, $pp2, $redundancy ) );
end


rule "Find part of redundant RulePossibility combination"
	when
		# PatternPossibility Redundancy.
		$redundancy :Redundancy()
		
		# Check that rules are redundant.
		$r1 :AnalyticsRule()
		$r2 :AnalyticsRule( id != $r1.id )
		Redundancy( 
			left == $r1, 
			right == $r2 
		)
		
		# Find two RulePossibilities.
		$rp1 :RulePossibility( 
			ruleId == $r1.id,
			items contains $redundancy.left 
		)
		$rp2 :RulePossibility( 
			ruleId == $r2.id, 
			items contains $redundancy.right 
		)
		# TODO: Not here.
	then
		insert( new PartialRedundancy( $rp1, $rp2, $redundancy ) );
end


#
# Handles both RulePossibilities and PatternPossibilities.
#
rule "Find subsumptant Possibilities"
	when
		$p1 :Possibility()
		$p2 :Possibility( id != $p1.id )
		
		not Subsumption( 
				left == $p1, 
				right == $p2 
		)
		
		# At least one partial redundancy exists between these possibilities.
		exists( 
				PartialRedundancy( 
					left == $p1, 
					right == $p2 
				) 
		)
		
		# Collect all the partial redundancies.
		$list :ArrayList()
			from collect(
				PartialRedundancy( 
					left == $p1, 
					right == $p2 
				)
			)
			
		# If there as much partial redundancies as there is items in $p1,
		# then $p1 is subsumptant to $p2.
		eval( $list.size() == $p1.getAmountOfItems() )
	then
		insert( new Subsumption( $p1, $p2 ) );
end

#
# If two possibilities are subsumptant to each others, then they are redundant.
# Since this tests only one possibility, the entire rule or pattern might not be redundant.
#
rule "Find redundant Possibilities"
	when
		$p1 :Possibility()
		$p2 :Possibility( id != $p1.id )
		
		not Redundancy( 
			left == $p1, 
			right == $p2 
		)
		
		not Redundancy( 
			left == $p2, 
			right == $p1 
		)
		
		Subsumption( 
				left == $p1, 
				right == $p2 
		)
		
		Subsumption( 
				left == $p2, 
				right == $p1 
		)
	then
		insert( new Redundancy( $p1, $p2 ) );
end

/*
#
# When two patterns and all theyr possibilities are redundant.
#
rule "Find redundant pattern"
	when
		$p1 :Pattern()
		$p2 :Pattern( id != $p1.id )
		
		$set1 :HashSet()
			from collect(
				PatternPossibility( patternId == $p1.id )
			)

		$set2 :HashSet()
			from collect(
				PatternPossibility( patternId == $p2.id )
			)
		
		# Check that sizes are the same.
		eval( $set1.size() == $set2.size() )
		
		$redundancyList :ArrayList()
			from collect(
				Redundancy( 
					eval( $set1.contains( left ) ),
					eval( $set2.contains( right ) )
				)
			)
		
		eval( $set1.size() == $redundancyList.size() )
		
	then
		# Type is set to strong because all the pattern possibilities are redundant.
		insert( new Redundancy( Redundancy.Type.STRONG, $p1, $p2 ) );
end

#
# When two rules and all theyr possibilities are redundant.
#
rule "Find redundant rule"
	when
		$r1 :AnalyticsRule()
		$r2 :AnalyticsRule( id != $r1.id )
		
		# If all the patterns in rule 1 are strongly redundant to rule 2, and vice versa.
		# Then the redundancy is strong.
		$set1 :HashSet()
			from collect(
				Pattern( ruleId == $r1.id )
			)

		$set2 :HashSet()
			from collect(
				Pattern( ruleId == $r2.id )
			)
		
		# Find only strong pattern
		$redundancyList :ArrayList()
			from collect(
				Redundancy( 
					type == Redundancy.Type.STRONG,
					eval( $set1.contains( left ) ),
					eval( $set2.contains( right ) )
				)
			)
		 
		eval( $set1.size() == $redundancyList.size() )
		
	then
		# Type is set to strong because all the rule possibilities are redundant.
		insert( new Redundancy( Redundancy.Type.STRONG, $r1, $r2 ) );
end
*/
/*
# TODO: Partial redundancy, when some two rulepossibilities from different rules 
# are redundant. but not all of the possibilities are redundant!
# NOTE: Write this one to to out put rules.
*/

















