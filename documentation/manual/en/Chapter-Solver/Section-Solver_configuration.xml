<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>Solver configuration</title>

  <section>
    <title>The Solver interface</title>

    <para>Every build-in solver implemented in drools-solver implements the
    <literal>Solver</literal> interface:</para>

    <programlisting>public interface Solver {

    void setStartingSolution(Solution solution);

    Number getBestScore();
    Solution getBestSolution();
    
    void solve();

    // ...

}</programlisting>

    <para>Solving a planning problem with drools-solver consists out of 4
    steps:</para>

    <orderedlist>
      <listitem>
        <para>Build a solver, for example a tabu search solver for any NQueens
        puzzle.</para>
      </listitem>

      <listitem>
        <para>Set a starting solution on the solver, for example an 4 Queens
        puzzle instance.</para>
      </listitem>

      <listitem>
        <para>Solve it.</para>
      </listitem>

      <listitem>
        <para>Get the best solution found by the solver.</para>
      </listitem>
    </orderedlist>

    <para>A <literal>Solver</literal> should currently directly be accessed
    from a single thread. Support from accessing it from a different thread,
    for example to finish solving early or to change the problem facts in
    real-time, will be added in future releases.</para>
  </section>

  <section>
    <title>Building a solver</title>

    <para>You can build a <literal>Solver</literal> instance with the
    <literal>XmlSolverConfigurer</literal> by configuring it with a solver
    configuration xml file:</para>

    <programlisting>    XmlSolverConfigurer configurer = new XmlSolverConfigurer();
    configurer.configure("/org/drools/solver/examples/nqueens/solver/nqueensSolverConfig.xml");
    Solver solver = configurer.buildSolver();</programlisting>

    <para>A basic solver configuration file looks something like this:</para>

    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;localSearchSolver&gt;
    &lt;scoreDrl&gt;/org/drools/solver/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
    &lt;scoreCalculator&gt;
        &lt;scoreCalculatorType&gt;SIMPLE&lt;/scoreCalculatorType&gt;
    &lt;/scoreCalculator&gt;
    &lt;finish&gt;
        &lt;feasableScore&gt;0.0&lt;/feasableScore&gt;
    &lt;/finish&gt;
    &lt;selector&gt;
        &lt;moveFactoryClass&gt;org.drools.solver.examples.nqueens.solver.NQueensMoveFactory&lt;/moveFactoryClass&gt;
    &lt;/selector&gt;
    &lt;accepter&gt;
        &lt;completeSolutionTabuSize&gt;1000&lt;/completeSolutionTabuSize&gt;
    &lt;/accepter&gt;
    &lt;forager&gt;
        &lt;foragerType&gt;MAX_SCORE_OF_ALL&lt;/foragerType&gt;
    &lt;/forager&gt;
&lt;/localSearchSolver&gt;</programlisting>

    <para>This is a tabu search configuration (which is a form of local
    search) for NQueens. We 'll explain the various parts of a configuration
    later in this manual.</para>

    <para><emphasis role="bold">Drools-solver makes it relatively easy to
    switch a solver type just by changing the configuration.</emphasis>
    There's even a benchmark utility which allows you to play out different
    configurations against each other and report the most appropriate
    configuration for your problem. You could for example play out tabu search
    versus simulated annealing, on a set of instances of your planning
    problem.</para>
  </section>

  <section>
    <title>The Solution interface</title>

    <para>A Solver can only solve 1 problem at a time. One problem has a lot
    of solutions, but few optimal solutions.</para>

    <para>You need to present the problem as a starting
    <literal>Solution</literal> instance to the Solver. Usually you will make
    that starting solution with a simple filler algorithm, for example: all
    queens on a different x and all on y = 0. It will probably be far from
    optimal, but that's ok, as it's the solver's job to find a much better
    solution.</para>

    <para>Here is the <literal>Solution</literal> interface:</para>

    <programlisting>public interface Solution {

    Solution cloneSolution();

    Collection&lt;? extends Object&gt; getFacts();

}</programlisting>

    <para>Most solvers use the <literal>cloneSolution()</literal> method to
    clone the solution each time they encounter a new best solution. The
    <literal>cloneSolution()</literal> method should clone no more and no less
    than the parts of the <literal>Solution</literal> that can change during
    solving. For example, in the lesson schedule example the lessons are
    cloned, but teachers, groups and timeslots are not cloned because only a
    lesson's appointed timeslot changes during solving:</para>

    <programlisting>    /**
     * Clone will only deep copy the lessons
     */
    public LessonSchedule cloneSolution() {
        LessonSchedule clone = new LessonSchedule();
        clone.timeslotList = timeslotList; // No Deep copy
        clone.teacherList = teacherList; // No Deep copy
        clone.groupList = groupList; // No Deep copy
        List&lt;Lesson&gt; clonedLessonList = new ArrayList&lt;Lesson&gt;(lessonList.size());
        for (Lesson lesson : lessonList) {
            clonedLessonList.add(lesson.clone());
        }
        clone.lessonList = clonedLessonList;
        return clone;
    }</programlisting>

    <para>The <literal>NQueens</literal> implementation just clones all
    <literal>Queen</literal> instances.</para>

    <para>All Objects returned by the <literal>getFacts()</literal> method
    will be asserted into the drools working memory. Those facts can be used
    by the score calculation rules. For example, <literal>NQueens</literal>
    just returns all <literal>Queen</literal> instances.</para>

    <programlisting>    public Collection&lt;? extends Object&gt; getFacts() {
        return queenList;
    }</programlisting>
  </section>

  <section>
    <title>Solving a problem</title>

    <para>Solving a problem is quite easy once you have a solver and the
    starting solution:</para>

    <programlisting>    solver.setStartingSolution(startingSolution);
    solver.solve();
    Solution bestSolution = solver.getBestSolution();</programlisting>

    <para>The <literal>solve()</literal> method will take a long time
    (depending on the problem size and the solver configuration). After a
    problem is solved, you can reuse the same solver to solve another problem
    (of the same problem type).</para>
  </section>
</section>