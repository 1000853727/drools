<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>Rete Algorithm</title>

  <para>The RETE algorithm was invented by Dr. Charles Forgy and documented in
  his PHd thesis in 1978-79. A simplified version of the paper was published
  in 1982 (<ulink
  url="http://citeseer.ist.psu.edu/context/505087/0">http://citeseer.ist.psu.edu/context/505087/0</ulink>).The
  word RETE is latin for "net" meaning network. RETE algorithm can be broken
  into 2 parts: rule compilation and runtime execution.</para>

  <para>The compilation algorithm describes how the Rules in the Production
  Memory to generate an efficient descrimination network. In non-technical
  terms, a descrimination network is used to filter data. The idea is to
  filter data as it propogates through the network. At the top, the nodes
  would have many matches. As we go down the network, there would be fewer
  matches. At the very bottom of the network are the terminal nodes. In Dr
  Forgy's 1982 paper, he described 4 basic nodes: root, 1-input, 2-input and
  terminal.</para>

  <para>The root node is where all objects enter the network. From there, it
  immediately goes to the ObjectTypeNode. The purpose of the ObjectTypeNode is
  to make sure the engine doesn't do more work than it needs to. For example,
  say we have 2 objects: Account and Order. If the rule engine tried to
  evaluate every single node against every object, it would waste a lot of
  cycles. To make things efficient, the engine should only pass the object to
  the nodes that match the object type. The easiest way to do this is to
  create an ObjectTypeNode and have all 1-input and 2-input nodes descend from
  it. This way, if an application asserts a new account, it won't propogate to
  the nodes for the Order object. Many modern RETE implementation have
  specialized ObjectTypeNode. In some cases, the ObjectTypeNode is further
  optimized using hashing.</para>

  <para>One input nodes are commonly called AlphaNodes. AlphaNodes are used to
  evaluate literal conditions. Although the 1982 paper only covers equality
  conditions, many RETE implementations support other operations. For example,
  Account.name == "Mark" is a literal conditions. When a rule has multiple
  literal conditions for a single object type, they are linked together. This
  means that if an application asserts an account object, it must first
  satisfy the first literal condition before it can proceed to the next
  AlphaNode. In Dr. Forgy's paper, he refers to these as IntraElement
  conditions. ObjectTypeNode mentioned in the previous paragraph is a
  specialized AlphaNode.</para>

  <para>Two input nodes are commonly called BetaNodes. BetaNodes are use to
  compare 2 objects to each other. The objects may be the same or different
  types. The left input for a BetaNode is generally a list of objects. The
  right input is a single object. In some cases, a rule engine may implement
  several BetaNodes to handle existential conditions and negated conditional
  element. Many modern RETE implementations also optimize BetaNodes through
  hash or b-tree indexes.</para>

  <para>Terminal nodes are used to indicate a single rule has matched all its
  conditions. In some cases, a rule with an OR disjunction can have more than
  1 terminal node. From a RETE network perspective a rule with OR disjunction
  is really just 2 nodes with many shared nodes.</para>

  <para>The second part of RETE algorithm is the runtime. When an application
  asserts an object, the engine passes the data to the root node. From there,
  it enters the ObjectTypeNode and propogates down the network. When the data
  matches the condition of a node, the node remembers it with an AlphaMemory.
  When the data reaches a BetaNode, the node adds it to the corresponding
  memory. The BetaNode will propogate the data, if there is a match between
  the right and left. This is done for several reasons. The primary benefit is
  faster performance. Although remembering all complete and partial matches
  takes memory, it provides a significant speed and scalability advantage.
  When all the conditions of a rule are satisfied, it is considered a complete
  match. Partial matches occur when some of the rules conditions match, but
  other conditions are not. Some rule engines optimize the Beta and Alpha
  memory for BetaNodes and attempt to reduce the number of evaluations between
  the data in the right and left inputs.</para>

  <para>In general, optimizing the runtime performance of RETE through
  additional indexing of the memories does not violate the basic intent and
  design of RETE algorithm.</para>
</section>