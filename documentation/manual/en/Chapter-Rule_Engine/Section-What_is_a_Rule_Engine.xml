<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>What is a Rule Engine</title>

  <section>
    <title>Introduction and Background</title>

    <para>Artificial Intelligence (A.I.) is a very broad research area that
    focuses on "Making computers think like people" and includes disciplines
    like Neural Networks, Genetic Algorithms, Decision Trees, Frame Systems
    and Expert Systems. Knowledge representation is the area of A.I. concerned
    with how knowledge is represented and manipulated. Expert Systems use
    Knowledge representation to facilitate the codification of knowledge into
    a knowledge base which can be used for reasoning - i.e. we can process
    data with this knowledge base to infer conclusions. Expert Systems are
    also known as Knowledge-based Systems and Knowledge-based Expert System
    and are considered 'applied artificial intelligence'; the process of
    developing with an Expert System is Knowledge Engineering. EMYCIN was one
    of the first "shells" for an Expert System, which was created from the
    MYCIN medical diagnosis Expert System. Where early Expert Systems had
    their logic hard coded "shells" separated the logic from the system,
    providing an easy to use environment for user input. Drools is a Rule
    Engine that uses the Rule Based approached to implement an Expert System
    and is more correctly classified as a Production Rule System.</para>

    <para>The term "Production Rule" originates from formal grammer - where it
    is described as "an abstract structure that describes a formal language
    precisely, i.e., a set of rules that mathematically delineates a (usually
    infinite) set of finite-length strings over a (usually finite) alphabet"
    (<ulink
    url="http://en.wikipedia.org/wiki/Formal_grammar">wikipedia</ulink>).</para>

    <para>Business Rule Management Systems build value on top of an Rule
    Engine providing systems for rule management, deployment, collaboration,
    analysis and end user tools for business users. Further to this the
    "Business Rules Approach" is a fast evolving and popular methodology
    helping to formalise the role of Rule Engines in the enterprise.</para>

    <para>The term Rule Engine is quite ambiguous in that it can be any system
    that uses rules, in any form, that can be applied to data to produce
    outcomes; which includes simple systems like form validation and dynamic
    expression engines: "How to Build a Business Rules Engine (2004)" by
    Malcolm Chisholm exemplifies this ambiguity. The book is actually about
    how to build and alter a database schema to hold validation rules which it
    then shows how to generate VB code from those validation rules to validate
    data entry - while a very valid and useful topic for some, it caused quite
    a suprise to this author, unaware at the time in the subtleties of Rules
    Engines differences, who was hoping to find some hidden secrets to help
    improve the Drools engine. jBPM uses expressions and delegates in its
    Decision nodes; which controls the transitions in a Workflow. At each node
    it evaluates a rule that dicates the transition to undertake - this is
    also a Rule Engine. While a Production Rule System is a kind of Rule
    Engine and also Expert System, the validation and expression evaluation
    Rule Engines mention previously are not Expert Systems.</para>

    <para>A Production Rule System is turing complete with a focus on
    knowledge representation to expression propositional and first order logic
    in a concise, non ambigious and declarative manner. The brain of a
    Production Rules System is an Inference Engine that is able to scale to a
    large number of rules and facts. The Inference Engine matches facts, the
    data, against Production Rules, also called Productions or just Rules, to
    infer conclusions which result in actions. A Production Rule is a two-part
    structure using First Order Logic for knowledge representation.</para>

    <programlisting>when
    &lt;conditions&gt;
then
    &lt;actions&gt;</programlisting>

    <para>The process of matching the new or existing facts against Production
    Rules is called <indexterm>
        <primary>Pattern Matching</primary>
      </indexterm> Pattern Matching, which is performed by the <indexterm>
        <primary>Inference Engine</primary>
      </indexterm>Inference Engine. There are a number of algorithms used for
    Pattern Matching by Inference Engines including:</para>

    <itemizedlist>
      <listitem>
        <para>Linear</para>
      </listitem>

      <listitem>
        <para>Rete</para>
      </listitem>

      <listitem>
        <para>Treat</para>
      </listitem>

      <listitem>
        <para>Leaps</para>
      </listitem>
    </itemizedlist>

    <para>Drools has implementations for both <indexterm>
        <primary>Rete</primary>
      </indexterm>Rete and <indexterm>
        <primary>Leaps</primary>
      </indexterm>Leaps; Leaps is considered experimental, as it is quite new.
    The Drools <indexterm>
        <primary>Rete</primary>
      </indexterm>Rete implementation is called ReteOO signifying that Drools
    has an enhanced and optimised implementation of the Rete algorithm for
    Object Oriented systems. Other Rete based engines also have marketing
    terms for their proprietary enhancements to Rete, like RetePlus and Rete
    III. It is important to understand that names like Rete III are purely
    marketing where, unlike the original published Rete Algorithm, no details
    of implementation are published; thus asking a question like "Does Drools
    implement Rete III?" is nonsensical. The most common enhancements are
    covered in "Production Matching for Large Learning Systems (Rete/UL)"
    (1995) by Robert B. Doorenbos.</para>

    <para>The Rules are stored in the the <indexterm>
        <primary>Production Memory</primary>
      </indexterm>Production Memory and the facts that the Inference Engine
    matches against the <indexterm>
        <primary>WorkingMemory</primary>
      </indexterm>Working Memory. Facts are asserted into the Working Memory
    where they may then be modiied or retracted. A system with a large number
    of rules and facts may result in many rules being true for the same fact
    assertion, these rules are said to be in conflict. The Agenda manages the
    execution order of these conflicuting rules using a Conflict Resolution
    stategy.</para>

    <figure>
      <title>A Basic Rete network</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="Rule_Engine.svg" format="SVG" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="Rule_Engine.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>A Production Rule System's Inference Engine is stateful and able to
    enforce truthfulness - called Truth Maintence. A logical relationship can
    be declared by actions which means the action's state depends on the
    inference remaining true; when it is no longer true the logical dependant
    action is undone. The "Honest Politician" is an example of Truth
    Maintenance, which always ensures that hope can only exist for a
    decomcracy while we have honest politicians.</para>

    <programlisting>when
    an honest Politician exists
then
    logically assert Hope

when
   Hope exists
then
   print "Hurrah!!! Democracy Lives" 

when
   Hope does not exist
then
   print "Democracy is Doomed" 
</programlisting>

    <para>There are two methods of execution for a Production Rule Systems -
    Forward Chaining and Backward Chaining; systems that implement both are
    called Hybrid Production Rule Systems. Understanding these two modes of
    operation are key to understanding why a Production Rule System is
    different and how to get the best from them. Forward chaing is
    'data-driven' and thus reactionary - facts are asserted into the working
    memory which results in one or more rules being concurrently true and
    scheduled for execution by t he Agenda - we start with a fact, it
    propagates and we end in a conclusion. Drools is a forward chaining
    engine.</para>

    <figure>
      <title>Forward Chaining</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="Forward_Chaining.svg"
                     format="SVG" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="Forward_Chaining.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Backward chaining is 'goal-driven', we start with a conclusion which
    the engine tries to satisfy. If it can't it searches for conclusions, 'sub
    goals', that help satisfy an unknown part fo the current goal - it
    continues this process untill either the initial conclusion is proven or
    there are no more sub goals. Prolog is an example of a Backward Chaining
    engine; Drools will adding support for Backward Chaining in its next major
    release.</para>

    <figure>
      <title>Backward Chaining</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="Backward_Chaining.svg"
                     format="SVG" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="Backward_Chaining.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>
</section>