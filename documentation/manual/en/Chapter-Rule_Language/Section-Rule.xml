<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="rule.svg" format="SVG" role="" />
      </imageobject>

      <imageobject>
        <imagedata align="center" fileref="rule.png" format="PNG" role="" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>The Rule construct is where is all happens. Rules are of the form "IF"
  something "THEN" action (of course we chose the keywords "when" and "then")
  - in the style of production rules.</para>

  <para>A rule must have a name, and be a unique name for a rule package. If a
  rule name is to have spaces, then it will need to be in double quotes (its
  best to always use double quotes.</para>

  <para>Attributes are optional, and are described below (they are best kept
  as one per line).</para>

  <para>The LHS of the rule follows the "when" keyword (ideally on a new
  line), similarly the RHS follows the "then" keyword (ideally on a newline).
  The rule is terminated by the keyword "end". Rules cannot be nested of
  course.</para>

  <section>
    <title>Left Hand Side</title>

    <para>The Left Hand Side (LHS) is a common the conditional part of the
    rule.</para>

    <para>To interpret the following diagram, refer to the sections below for
    the details.</para>

    <figure>
      <title>Left Hand Side</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="lhs.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="lhs.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>pattern</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="pattern.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="pattern.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Rule Attriutes</title>

    <para></para>

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="rule_attributes.svg" format="SVG" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="rule_attributes.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>no-loop</title>

      <para>default value : false</para>

      <para>type : Boolean</para>

      <para>When the Rule's consequence modifies a fact it may cause the Rule
      to activate again, causing recursion. Setting no-loop to true means the
      attempt to create the Activation will be ignored.</para>
    </section>

    <section>
      <title>salience</title>

      <para>default value : 0</para>

      <para>type : integer</para>

      <para>Each rule has a salience attribute that can be assigned an Integer
      number, defaults to zero, the Integer and can be negative or positive.
      Salience is a form of priority where rules with higher salience values
      are given higher priority when ordered in the Activation queue.</para>
    </section>

    <section>
      <title>agenda-group</title>

      <para>default value : MAIN</para>

      <para>type : String</para>

      <para>Agenda group's allow the user to partition the Agenda providing
      more execution control. Only rules in the focus group are allowed to
      fire.</para>
    </section>

    <section>
      <title>auto-focus</title>

      <para>default value false</para>

      <para>type : Boolean</para>

      <para>When a rule is activated if the <literal>auto-focus value is true
      and the Rule's </literal> <literal>agenda-group</literal> does not have
      focus then it is given focus, allowing the rule to potentially
      fire.</para>
    </section>

    <section>
      <title>duration</title>

      <para>default value : no default value</para>

      <para>type : long</para>

      <para></para>
    </section>
  </section>

  <section>
    <title>Column</title>

    <figure>
      <title>Column</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="column.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="column.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Column</title>

      <programlisting>Cheese( )
Cheese( type == "stilton", price &lt; 10 )</programlisting>
    </example>

    <para>A Column is what Drools calls a list of constraints on an Object
    type. The above cases refer to constraints against instances of a Cheese
    object. In the first case, there are obviously no constraints, so this
    Column will match all instances of Cheese that it finds in working memory.
    In the latter case, there are 2 constraints on "fields" that must be met
    before the Cheese object will be matched (they are seperated by a comma,
    which implicitly means "and").</para>

    <figure>
      <title>Column</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="bound_column.svg" format="SVG"
                     role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="bound_column.png" format="PNG"
                     role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Bound Column</title>

      <programlisting>cheapStilton : Cheese( type == "stilton", price &lt; 10 )</programlisting>
    </example>

    <para>This is similar to the previous case, but in this case we are
    binding a variable to that instance of Cheese that the rule engine will
    match. This means you can use cheapStilton in another condition, or
    perhaps in the consequence part of the rule. You can also eat it, but I
    wouldn't.</para>

    <section>
      <title>Field Constraints</title>

      <para>Field constraints place constraints on the Fact objects for the
      rule engine to match/select out of working memory. They work
      comparing/evaluating "field" values from the fact object
      instances.</para>

      <para>A "field" is not a field in the sense of a public or private
      member of a class. A field is an accessible method. If your model
      objects follow the java bean pattern, then fields are accessed via
      "getXXX" or "isXXX" methods (these are methods that take no arguments,
      and return something). You can access fields either by using the
      bean-name convention (so "getType" can be accessed as "type") or by
      specifying the whole method name (without any brackets). </para>

      <para>For example, refering to our Cheese class, the following are
      equivalent: Cheese(type == ...), and Cheese(getType == ...). This means
      that you can use model objects that aren't strictly java beans. However,
      make sure that you are accessing methods that take no parameters, and
      are infact "accessors" (as in, they don't change the state of the object
      in a way that may effect the rules - remember that the rule engine
      effectively caches the results of its matching inbetween invocations to
      make it faster).</para>

      <section>
        <title>Operators</title>

        <figure>
          <title>Operators</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="operator.svg" format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="operator.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>There are a number of <indexterm>
            <primary>operatorst</primary>
          </indexterm>opreators that can be used with the various <indexterm>
            <primary>Field Constraint</primary>
          </indexterm>Field Constraints. Valid operators are dependent on the
        field type. Generally they are self explanatory based on the type of
        data: for instance, for date fields, "&lt;" means "before" and so on.
        "Matches" is only applicable to string fields, and "contains" is only
        applicable to Collection type fields.</para>
      </section>

      <section>
        <title>Literal Constraints</title>

        <para>The most basic of Field Constraints is the <indexterm>
            <primary>Literal Constraint</primary>
          </indexterm>Literal Constraint which allows the user to constrain a
        field to a given value.</para>

        <para>A note on nulls: you can do checks against fields that are or
        maybe null, using == and != as you would expect, and the literal
        "null" keyword, like: Cheese(type != null).</para>

        <figure>
          <title>Literal Constraints</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="literal_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="literal_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <simplesect>
          <title>Numeric</title>

          <para>All standard java numeric primitives are supported</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>

            <listitem>
              <para>&gt;</para>
            </listitem>

            <listitem>
              <para>&lt;</para>
            </listitem>

            <listitem>
              <para>&gt;=</para>
            </listitem>

            <listitem>
              <para>&lt;=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Numeric Literal Constraint</title>

            <programlisting>Cheese( quantity == 5 )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Date</title>

          <para>Currently only "dd-mmm-yyyy" date format is supported. There
          are plans to make this configurable in the future.</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>

            <listitem>
              <para>&gt;</para>
            </listitem>

            <listitem>
              <para>&lt;</para>
            </listitem>

            <listitem>
              <para>&gt;=</para>
            </listitem>

            <listitem>
              <para>&lt;=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Date Literal Constraint</title>

            <programlisting>Cheese( bestBefore &lt; "27-Oct-2007" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>String</title>

          <para>Any valid Java String is allowed.</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>String Literal Constraint</title>

            <programlisting>Cheese( type == "stilton" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Boolean</title>

          <para>only true or false can be used. 0 and 1 are not recognised,
          nor is <literal>Cheese ( smelly )</literal> is not allowed</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>true</para>
            </listitem>

            <listitem>
              <para>false</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Boolean Literal Constraint</title>

            <programlisting>Cheese( smelly = true )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Matches Operator</title>

          <para>Any valid Java <indexterm>
              <primary>regular expression</primary>
            </indexterm>Regular Expression can be used to match String
          fields.</para>

          <example>
            <title>Regular Expression Constraint</title>

            <programlisting>Cheese( type matches "(Buffulo)?\\S*Mozerella" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Contains Operator</title>

          <para><literal>'contains' </literal>is a special operator that can
          be used to check if a field's <indexterm>
              <primary>Collection</primary>
            </indexterm>Collection contains a String literal.</para>

          <example>
            <title>Literal Cosntraints with Collections</title>

            <programlisting>CheeseCounter( cheeses contains "stilton" )</programlisting>
          </example>
        </simplesect>
      </section>

      <section>
        <title>Bound Variable Constraint</title>

        <figure>
          <title>Bound Variable Declaration</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="boundvariable_constraints.svg" format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center"
                         fileref="boundvariable_constraints.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Variables can be bound to Facts and and Fields and then used in
        subsequent Field Constraints. A bound variable is called a <indexterm>
            <primary>declaration</primary>
          </indexterm>Declaration. Declarations cannot be used with
        <literal>'matches'</literal>, although it works with
        <literal>'contains'</literal>. Valid operators are determined by the
        type of the field being constrained.</para>

        <example>
          <title>Bound Field using '==' operator</title>

          <programlisting>Person( likes : favouriteCheese )
Cheese( type == likes )</programlisting>
        </example>

        <example>
          <title>Bound Fact using 'contains' operator</title>

          <programlisting>stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains stilton )</programlisting>
        </example>
      </section>

      <section>
        <title>Predicate Constraints</title>

        <figure>
          <title>Predicate expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="predicate_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="predicate_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>A <indexterm>
            <primary>Predicate</primary>
          </indexterm>Predicate constraint can use any valid Java expression
        as long as it evaluated to a primitive boolean. Previously bound
        declarations can be used in the expression. All bound primitive
        declarations are boxed, there is currently no auto-unboxing.</para>

        <para>This example will find all pairs of male/femal people where the
        male is 2 years older than the female.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( boyAge : age -&gt; ( girlAge == boyAge + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>

      <section>
        <title>Return Value Constraints</title>

        <figure>
          <title>Return Value expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="returnvalue_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="returnvalue_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>A <indexterm>
            <primary>Return Value</primary>
          </indexterm>Return Value constraint can use any valid Java
        expression as long as it returns an object, it cannot return
        primitives. Previously bound declarations can be used in the
        expression. All bound primitive declarations are boxed, there is
        currently no auto-unboxing. The returned value must be boxed if its a
        primitive.</para>

        <para>Like the Predicate example this will find all pairs of
        male/femal people where the male is 2 years older than the female.
        Notice here we didn't have to bind the boyAge, making it a little
        simpler to read.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( age == ( girlAge + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>
    </section>
  </section>

  <section>
    <title>Conditional Elements</title>

    <para>uuuere</para>

    <section>
      <title>'and'</title>

      <figure>
        <title>and</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="and.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="and.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : and, or, not, exists, column</para>

      <example>
        <title>Column</title>

        <programlisting>Cheese( cheeseType : type ) &amp;&amp; Person( favouriteCheese == cheeseType )
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )</programlisting>
      </example>
    </section>

    <section>
      <title>'or'</title>

      <figure>
        <title>or</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="or.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="or.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : and, or, not, exists, column</para>

      <example>
        <title>or</title>

        <programlisting>Person( sex == "f", age &gt; 60 ) || Person( sex == "m", age &gt; 65 )
Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 )
</programlisting>
      </example>

      <figure>
        <title>or</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="or_with_binding.svg"
                       format="SVG" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="or_with_binding.png"
                       format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>or with binding</title>

        <programlisting>pensioner : ( Person( sex == "f", age &gt; 60 ) || Person( sex == "m", age &gt; 65 ) )
pensioner : ( Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 ) )</programlisting>
      </example>

      <para></para>
    </section>

    <section>
      <title>'eval'</title>

      <figure>
        <title>eval</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="eval.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="eval.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : none</para>

      <para>Evals cannot be indexed and thus are not as optimal as using Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints.</para>

      <example>
        <title>or</title>

        <programlisting></programlisting>
      </example>
    </section>

    <section>
      <title>'not'</title>

      <figure>
        <title>not</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="not.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="not.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children: Column</para>

      <para>Future versions of Drools will allow 'and' and 'or' to be nested
      in 'not'</para>

      <example>
        <title>No Busses</title>

        <programlisting>not Bus()</programlisting>
      </example>

      <example>
        <title>No red Busses</title>

        <programlisting>not Bus(color == "red")</programlisting>
      </example>
    </section>

    <section>
      <title>'exists'</title>

      <figure>
        <title>exists</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="exists.svg" format="SVG" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="exists.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children: Column</para>

      <para>Future versions of Drools will allow 'and' and 'or' to be nested
      in 'not'</para>

      <example>
        <title>Atleast one Busses</title>

        <programlisting>exists Bus()</programlisting>
      </example>

      <example>
        <title>Atleast one red Busses</title>

        <programlisting>exists Bus(color == "red")</programlisting>
      </example>
    </section>

    <section>
      <title>'group'</title>

      <figure>
        <title>group</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="group.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="group.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>
    </section>
  </section>
</section>