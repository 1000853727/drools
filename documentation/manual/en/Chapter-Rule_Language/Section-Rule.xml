<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="rule.svg" format="SVG" role="" />
      </imageobject>

      <imageobject>
        <imagedata align="center" fileref="rule.png" format="PNG" role="" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>A rule specifies that "when" a particular set of conditions occur,
  specified in the Left Hand Side (LHS), then do this, which is specified as a
  list of actions in the Right Hand Side (RHS). A common question from users
  is "why use when instead of if". "when" was chosen over "if" becuase "if" is
  normally part of a procedural execution flow, where at a specific point in
  time it checks the condition. Where as "when" indicates it's not tied to a
  specific evaluation sequence or point in time, at any time during the life
  time of the engine "when" this occurs, do that. Rule</para>

  <para>A rule must have a name, and be a unique name for the rule package. If
  you define a rule twice in the same DRL it produce an error while loading.
  If you add a DRL that has includes a rule name already in the package, it
  will replace the previous rule. If a rule name is to have spaces, then it
  will need to be in double quotes (its best to always use double
  quotes).</para>

  <para>Attributes are optional, and are described below (they are best kept
  as one per line).</para>

  <para>The LHS of the rule follows the "when" keyword (ideally on a new
  line), similarly the RHS follows the "then" keyword (ideally on a newline).
  The rule is terminated by the keyword "end". Rules cannot be nested of
  course.</para>

  <example>
    <title>Rule Syntax Overview Example</title>

    <programlisting>rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</programlisting>
  </example>

  <example>
    <title>A rule example</title>

    <programlisting>rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</programlisting>
  </example>

  <section>
    <title>Rule Attriutes</title>

    <para>Rule attributes provide a declarative way to influence the behaviour
    of the rule, some are quite simple, while others are part of complex sub
    systems; such as ruleflow. To get the most from Drools you should make
    sure you have a proper understanding of each attribute.</para>

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="rule_attributes.svg" format="SVG" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="rule_attributes.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>no-loop</title>

      <para>default value : false</para>

      <para>type : Boolean</para>

      <para>When the Rule's consequence modifies a fact it may cause the Rule
      to activate again, causing recursion. Setting no-loop to true means the
      attempt to create the Activation for the current set of data will be
      ignored.</para>
    </section>

    <section>
      <title>salience</title>

      <para>default value : 0</para>

      <para>type : integer</para>

      <para>Each rule has a salience attribute that can be assigned an Integer
      number, defaults to zero, the Integer and can be negative or positive.
      Salience is a form of priority where rules with higher salience values
      are given higher priority when ordered in the Activation queue.</para>
    </section>

    <section>
      <title>agenda-group</title>

      <para>default value : MAIN</para>

      <para>type : String</para>

      <para>Agenda group's allow the user to partition the Agenda providing
      more execution control. Only rules in the focus group are allowed to
      fire.</para>
    </section>

    <section>
      <title>auto-focus</title>

      <para>default value false</para>

      <para>type : Boolean</para>

      <para>When a rule is activated if the <literal>auto-focus value is true
      and the Rule's </literal> <literal>agenda-group</literal> does not have
      focus then it is given focus, allowing the rule to potentially
      fire.</para>
    </section>

    <section>
      <title>activation-group</title>

      <para>default value : N/A</para>

      <para>type : String</para>

      <para>Rules that belong to the same named activation-group will only
      fire exclusively. In other words, the first rule in an activation-group
      to fire will cancel the other rules activations (stop them from firing).
      The Activtion group attribute is any string, as long as the string is
      identical for all the rules you need to be in the one group.</para>

      <para>NOTE: this used to be called Xor group, but technically its not
      quite an Xor, but you may hear people mention Xor group, just swap that
      term in your mind with activation-group.</para>
    </section>

    <section>
      <title>dialect</title>

      <para>default value : as specified by the package</para>

      <para>type : String</para>

      <para>The dialect species the language to be used for any code
      expressions in the LHS or the RHS code block. Currently two dialects are
      available, Java and MVEL. While the dialect can be specified at the
      package level, this attribute allows the package definition to be
      overriden.</para>
    </section>

    <section>
      <title>date-effective</title>

      <para>default value : N/A</para>

      <para>type : String, which contains a Date/Time definition</para>

      <para>A rule can only activate if the current date and time is afer
      date-effective attribute.</para>
    </section>

    <section>
      <title>date-exptires</title>

      <para>default value : N/A</para>

      <para>type : String, which contains a Date/Time definition</para>

      <para>A rule cannot activate if the current date and time is afer
      date-expires attribute.</para>
    </section>

    <section>
      <title>duration</title>

      <para>default value : no default value</para>

      <para>type : long</para>

      <para>The duration dictates that the rule will fire after a specified
      duration, if it is still true.</para>
    </section>

    <example>
      <title>Some attribute examples</title>

      <programlisting>rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</programlisting>
    </example>
  </section>

  <section id="RuleLanguage-ConditionalElements">
    <title>Left Hand Side (when) Conditional Elements</title>

    <para>The Left Hand Side (LHS) is a common name for the conditional part
    of the rule. It consists of zero or more Conditional Elements. If the LHS
    is left empty it is re-written as eval(true), which means the rule is
    always true, and will be activated with a new Working Memory session is
    created.</para>

    <figure>
      <title>Left Hand Side</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="lhs.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="lhs.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Rule Syntax Overview Example</title>

      <programlisting>rule "no CEs"
when
then
    &lt;action&gt;*
end</programlisting>

      <para>Is internally re-written as:</para>

      <programlisting>rule "no CEs"
when
    eval( true )
then
    &lt;action&gt;*
end</programlisting>
    </example>

    <para>Conditional elements work on one or more Columns (which were
    described above). The most common one is "and" which is implicit when you
    have multiple Columns in the LHS of a rule that are not connected in
    anyway. Note that an 'and' cannot have a leading declaration binding like
    'or' - this is obvious when you think about it. A declaration can only
    reference a single Fact, when the 'and' is satisfied it matches more than
    one fact - which fact would the declaration bind to?</para>

    <section>
      <title>Pattern</title>

      <para>The Pattern element is the most important Conditional Element. The
      entity relationship diagram below provides an overview of the various
      parts that make up the Pattern's constraints and how they work together;
      each is then covered in more detail with rail road diagrams and
      examples.</para>

      <figure>
        <title>Pattern Entity Relationship Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="patternER.svg" format="SVG"
                       role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="patternER.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>At the top of the ER diagram you can see that the pattern consists
      of zero or more constriants and has an optional pattern binding. The
      rail road diagram below shows the syntax for this.</para>

      <figure>
        <title>Pattern</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="pattern.svg" format="SVG"
                       role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="pattern.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>At the simplest, with no constraints, it simply matches against a
      type, in the following case the type is "Cheese". This means the pattern
      will match against all Cheese objects in the Working Memory.</para>

      <example>
        <title>Pattern</title>

        <programlisting>Cheese( )</programlisting>
      </example>

      <para>To be able to refer to the matched object use a pattern binding
      variable such as '$c'. While this example variable is prefixed with a $
      symbol, it is optional, but can be useful in complex rules as it helps
      to more easily differentiation between variables and fields.</para>

      <example>
        <title>Pattern</title>

        <programlisting>$c : Cheese( )</programlisting>
      </example>

      <para>Inside of the Pattern parenthesis is where all the action happens.
      A constraint can be either a Field Constraint, Inline Eval (called a
      predicate in 3.0) or a Constraint Group. Constraints can be seperated by
      the following symboles ',', '&amp;&amp;' or '||'.</para>

      <figure>
        <title>Constraints</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="constraints.svg" format="SVG"
                       role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="constraints.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>Constraint</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="constraint.svg" format="SVG"
                       role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="constraint.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>Group Constraint</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="constraintGroup.svg"
                       format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="constraintGroup.png"
                       format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>',' and '&amp;&amp;' when used without '||' are equivalent;. ','
      is provided as a less verbose '&amp;&amp;' connective for more simple
      field constraints.</para>

      <example>
        <title>Equivalent connectives</title>

        <programlisting>Cheese( type == "stilton", price &lt; 10 ) // valid
Cheese( type == "stilton" &amp;&amp; price &lt; 10 ) valid</programlisting>
      </example>

      <para>However only '&amp;&amp;' can be used with '||'.</para>

      <example>
        <title>Not Equivalent connectives</title>

        <programlisting>Cheese( type == "stilton", price &lt; 10 || age == "mature" ) // invalid
Cheese( type == "stilton" &amp;&amp; price &lt; 10 || age == "mature") // valid</programlisting>
      </example>

      <para>Constraints can be grouped using parenthesis; notice from the
      railroad and the ER diagram that this provides a recursive nature to the
      use of constraints in a Pattern.</para>

      <example>
        <title>Grouping with Parenthesis</title>

        <programlisting>Cheese( type == "stilton", ( price &lt; 10 || age == "mature" ) ) // valid
Cheese( type == "stilton" &amp;&amp; ( price &lt; 10 || age == "mature" ) ) // valid</programlisting>
      </example>

      <section>
        <title>Field Constraints</title>

        <para>A Field constraint specifies a restriction to be used on a field
        name; the field name can have an optional variable binding.</para>

        <figure>
          <title>fieldConstraint</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="fieldConstraint.svg"
                         format="SVG" role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="fieldConstraint.png"
                         format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>There are three types of restrictions; Single Value Restriction,
        Compount Value Restriction and Multi Restrictoin.</para>

        <figure>
          <title>restriction</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="restriction.svg" format="SVG"
                         role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="restriction.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>A field is an accessible method on the object. If your model
        objects follow the java bean pattern, then fields are exposed using
        "getXXX" or "isXXX" methods (these are methods that take no arguments,
        and return something). You can access fields either by using the
        bean-name convention (so "getType" can be accessed as "type").</para>

        <para>For example, refering to our Cheese class, the following :
        Cheese(type == ...) uses the getType() method on the a cheese
        instance. You can also access non getter methods, like "toString()" on
        the Object for instance (in which case, you do Cheese(toString == ..)
        - you use the full name of the method with correct capitalisation, but
        not brackets). Do please make sure that you are accessing methods that
        take no parameters, and are in-fact "accessors" (as in, they don't
        change the state of the object in a way that may effect the rules -
        remember that the rule engine effectively caches the results of its
        matching inbetween invocations to make it faster).</para>

        <section>
          <title>JavaBeans as facts</title>

          <para>A field is an accessible method on the object. If your model
          objects follow the java bean pattern, then fields are exposed using
          "getXXX" or "isXXX" methods (these are methods that take no
          arguments, and return something). You can access fields either by
          using the bean-name convention (so "getType" can be accessed as
          "type") - we use the standard jdk Introspector class to do this
          mapping.</para>

          <para>For example, refering to our Cheese class, the following :
          Cheese(type == ...) uses the getType() method on the a cheese
          instance. If a field name cannot be found it will resort to calling
          the name as a no argument method; "toString()" on the Object for
          instance can be used with Cheese(toString == ..) - you use the full
          name of the method with correct capitalisation, but not brackets. Do
          please make sure that you are accessing methods that take no
          parameters, and are in-fact "accessors" (as in, they don't change
          the state of the object in a way that may effect the rules -
          remember that the rule engine effectively caches the results of its
          matching inbetween invocations to make it faster).</para>
        </section>

        <section>
          <title>Values</title>

          <para>The field constraints can take a number of values; including
          literal, qualifiedIdentifier (enum), variable and
          returnValue.</para>

          <figure>
            <title>literal</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="literal.svg" format="SVG" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="literal.png" format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>qualifiedIdentifier</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="qualifiedIdentifier.svg"
                           format="SVG" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="qualifiedIdentifier.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>variable</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="identifier.svg"
                           format="SVG" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="identifier.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>returnValue</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="returnValue.svg"
                           format="SVG" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="returnValue.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>You can do checks against fields that are or maybe null, using
          == and != as you would expect, and the literal "null" keyword, like:
          Cheese(type != null). If a field is null the evaluator will not
          throw an expception and will only return true if the value is a null
          check. Coercion is always attempted if the field and the value are
          of different types; exceptions will be thrown if bad coercions are
          attempted. i.e. if "ten" is provided as a string in a number
          evaluator, where as "10" would coerce to a numeric 10. Coercion is
          always in favour of the field type and not the value type.</para>
        </section>

        <section>
          <title>Single Value Restriction</title>

          <figure>
            <title>singleValueRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="singleValueRestriction.svg"
                           format="SVG" role="" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="singleValueRestriction.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <section>
            <title>Operators</title>

            <figure>
              <title>Operators</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="operator.svg"
                             format="SVG" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="operator.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Valid operators are dependent on the field type. Generally
            they are self explanatory based on the type of data: for instance,
            for date fields, "&lt;" means "before" and so on. "Matches" is
            only applicable to string fields, "contains" and "not contains" is
            only applicable to Collection type fields. These operators can be
            used with any value and coercion to the correct value for the
            evaluator and filed will be attempted, as mention in hte "Values"
            secion.</para>

            <simplesect>
              <title>Matches Operator</title>

              <para>Matches a field against any valid Java <indexterm>
                  <primary>regular expression</primary>
                </indexterm>Regular Expression. Typically that regexp is a
              String, but variables that resolve to a valid regexp are also
              allowed.</para>

              <example>
                <title>Regular Expression Constraint</title>

                <programlisting>Cheese( type matches "(Buffulo)?\\S*Mozerella" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Not Matches Operator</title>

              <para>Any valid Java <indexterm>
                  <primary>regular expression</primary>
                </indexterm>Regular Expression can be used to match String
              fields. Returns true when the match is false. Typically that
              regexp is a String, but variables that resolve to a valid regexp
              are also allowed.</para>

              <example>
                <title>Regular Expression Constraint</title>

                <programlisting>Cheese( type not matches "(Buffulo)?\\S*Mozerella" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Contains Operator</title>

              <para><literal>'contains'</literal> is used to check if a
              field's <indexterm>
                  <primary>Collection</primary>
                </indexterm>Collection contains the specified value.</para>

              <example>
                <title>Contains with Collections</title>

                <programlisting>CheeseCounter( cheeses contains "stilton" ) //contains with a String literal
CheeseCounter( cheeses contains $var ) //contains with a variable</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>not containts</title>

              <para><literal>'not contains'</literal> is used to check if a
              field's <indexterm>
                  <primary>Collection</primary>
                </indexterm>Collection does not contains an object.</para>

              <example>
                <title>Literal Constraints with Collections</title>

                <programlisting>CheeseCounter( cheeses not contains "cheddar" ) //contains with a String literal
CheeseCounter( cheeses not contains $var ) //contains with a variable</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>memberof</title>

              <para><literal>'memberof' is used to check if a field is a
              member of a collection; that collection must be be a
              variable.</literal></para>

              <example>
                <title>Literal Constraints with Collections</title>

                <programlisting>CheeseCounter( cheese memberof $matureCheeses )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>not memberof</title>

              <para><literal>'not memberof' is used to check if a field is not
              a member of a collection; that collection must be be a
              variable.</literal></para>

              <example>
                <title>Literal Constraints with Collections</title>

                <programlisting>CheeseCounter( cheese not memberof $matureCheeses )</programlisting>
              </example>
            </simplesect>
          </section>

          <section>
            <title>Literal Restrictions</title>

            <para>Literal restrrictions are the simplest for of restrictions
            and evaluate a field against a specified literal; numeric, date,
            string and boolean.</para>

            <figure>
              <title>literalRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="literalRestriction.svg"
                             format="SVG" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="literalRestriction.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Literal Restrictions using the '==' operator, provide for
            faster execution as we can index using hashing to improve
            performance;</para>

            <simplesect>
              <title>Numeric</title>

              <para>All standard java numeric primitives are supported.</para>

              <example>
                <title>Numeric Literal Restriction</title>

                <programlisting>Cheese( quantity == 5 )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Date</title>

              <para>The date format "dd-mmm-yyyy" is supported by default. You
              can customise this by providing an alternative date format mask
              as a System property ("drools.dateformat" is the name of the
              property). If more control is required, use the predicate
              constraint.</para>

              <example>
                <title>Date Literal Restriction</title>

                <programlisting>Cheese( bestBefore &lt; "27-Oct-2007" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>String</title>

              <para>Any valid Java String is allowed.</para>

              <example>
                <title>String Literal Restriction</title>

                <programlisting>Cheese( type == "stilton" )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Boolean</title>

              <para>only true or false can be used. 0 and 1 are not
              recognised, nor is <literal>Cheese ( smelly )</literal> is not
              allowed</para>

              <example>
                <title>Boolean Literal Restriction</title>

                <programlisting>Cheese( smelly == true )</programlisting>
              </example>
            </simplesect>

            <simplesect>
              <title>Qualified Identifier</title>

              <para>Enums can be used as well, both jdk1.4 and jdk5 style
              enums are supported - for the later you must be executing on a
              jdk5 environment.</para>

              <example>
                <title>Boolean Literal Restriction</title>

                <programlisting>Cheese( smelly == SomeClass.TRUE )</programlisting>
              </example>
            </simplesect>
          </section>

          <section>
            <title>Bound Variable Restriction</title>

            <figure>
              <title>variableRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="variableRestriction.svg"
                             format="SVG" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="variableRestriction.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>Variables can be bound to Facts and their Fields and then
            used in subsequent Field Constraints. A bound variable is called a
            <indexterm>
                <primary>declaration</primary>
              </indexterm>Declaration. Valid operators are determined by the
            type of the field being constrained; coersion will be attempted
            where possible. Bound Variable Restrictions using '==' operator,
            provide for very fast execution as we can index using hashing to
            improve performance.</para>

            <example>
              <title>Bound Field using '==' operator</title>

              <programlisting>Person( likes : favouriteCheese )
Cheese( type == likes )</programlisting>

              <para>'likes' is our variable, our Declaration, that is bound to
              the favouriteCheese field for any matching Person instance and
              is used to constrain the type of Cheese in the following
              Pattern. Any valid java variable name can be used, including
              '$'; which you will often see used to help differentiate
              declarations from fields. The exampe below shows a declaration
              bound to the Patterns Object Type instance itself and used with
              a 'contains' operator, note the optional use of '$' this
              time.</para>
            </example>

            <example>
              <title>Bound Fact using 'contains' operator</title>

              <programlisting>$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</programlisting>
            </example>
          </section>

          <section>
            <title>Return Value Restriction</title>

            <figure>
              <title>returnValueRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
                             fileref="returnValueRestriction.svg" format="SVG" />
                </imageobject>

                <imageobject>
                  <imagedata align="center"
                             fileref="returnValueRestriction.png" format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>A <indexterm>
                <primary>Return Value</primary>
              </indexterm>Return Value restrriction can use any valid Java
            primitive or object. Avoid using any Drools keywords as
            Declaration identifiers. Functions used in a Return v</para>

            <para>Value Restriction must return time constant results.
            Previously bound declarations can be used in the
            expression.</para>

            <example>
              <title>Return Value Restriction</title>

              <programlisting>Person( girlAge : age, sex == "F" )
Person( age == ( girlAge + 2) ), sex == 'M' )
</programlisting>
            </example>
          </section>
        </section>

        <section>
          <title>Compound Value Restriction</title>

          <para>The compound value restriction is used where there is more
          than one possible value, currently only the 'in' and 'not in'
          evaluators support this. The operator takes a parenthesis enclosed
          comma seperated list of values, which can be a variable, literla,
          return value or qualified identifier.The 'in' and 'not in'
          evaluators are actually sugar and are rewriten as a multi
          restriction list of != and == restrictions.</para>

          <figure>
            <title>compoundValueRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
                           fileref="compoundValueRestriction.svg" format="SVG"
                           role="" />
              </imageobject>

              <imageobject>
                <imagedata align="center"
                           fileref="compoundValueRestriction.png" format="PNG"
                           role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para></para>

          <example>
            <title>Compound Restriction using 'in'</title>

            <programlisting>Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese )
</programlisting>
          </example>
        </section>

        <section>
          <title>Multi Restriction</title>

          <para>Multi restriction allows you to place more than restriction on
          a field using the '&amp;&amp;' or '||' restriction connectives,
          grouping via parenthesis is also allowed; which adds a recursive
          nature to this restriction.</para>

          <figure>
            <title>multiRestriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="multiRestriction.svg"
                           format="SVG" role="" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="multiRestriction.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <figure>
            <title>restrictionGroup</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="restrictionGroup.svg"
                           format="SVG" role="" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="restrictionGroup.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para></para>

          <example>
            <title>Multi Restriction</title>

            <programlisting>Person( age &gt; 30 &amp;&amp; &lt; 40 ) // simple multi restriction using a single &amp;&amp;
Person( age ( (&gt; 30 &amp;&amp; &lt; 40) || (&gt; 20 &amp;&amp; &lt; 20) ) ) // more complex multi restriction using groupings of multi restrictions
Person( age &gt; 30 &amp;&amp; &lt; 40 || location == "london" ) // mixing muti restrictions with constraint connectives</programlisting>
          </example>
        </section>
      </section>

      <section>
        <title>Inline Eval Constraints</title>

        <figure>
          <title>Inline Eval Expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="inlineEvalConstraint.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="inlineEvalConstraint.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>A <indexterm>
            <primary>Predicate</primary>
          </indexterm>inline-eval constraint can use any valid dialect
        expression as long as it evaluated to a primitive boolean - avoid
        using any Drools keywords as Declaration identifiers. the expression
        must be time constant. Any previous bound variable, from the current
        or previous pattern, can be used; autovivification is also used to
        auto create field binding variables. When an identifier is found that
        is not a current variable the builder looks to see if the identifier
        is a field on the current object type, if it is the field is auto
        created as a variable of the same name; this is autovivification of
        field varables inside of inline evals.</para>

        <para>This example will find all pairs of male/femal people where the
        male is 2 years older than the female; the girlAge variable is auto
        created as part of the autovivification process.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( eval( girlAge == boyAge + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>

      <section>
        <title>Nested Accessors</title>

        <para>Drools does allow for nested accessors in in the field
        constraints using the MVEL accessor graph notation. Field constraints
        involving nested accessors are actually re-written as an MVEL dialect
        inline-eval. Care should be taken when using nested accessors as the
        Working Memory is not aware of any of the nested values, and do not
        know when they change; they should be considered immutable while any
        of their parent references are inserted into the Working Memory. If
        you wish to modify a nested value you should remove he parent objects
        first and re-assert afterwards. If you only have a single parent at
        the root of the graph you, when in the MVEL dialect, you can use the
        'modify' keyword and its block setters to write the nested accessor
        assingments while retracting and inserting the the root parent object
        as required. Nested accessors can be used either side of the operator
        symbol.</para>

        <example>
          <title>Nested Accessors</title>

          <programlisting>$p : Person( ) 
Pet( owner == $p, age &gt; $p.children[0].age ) // Find a pet who is older than their owners first born child</programlisting>

          <para>is internally rewriten as an MVEL inline eval:</para>

          <programlisting>$p : Person( ) 
Pet( owner == $p, eval( age &gt; $p.children[0].age ) ) // Find a pet who is older than their owners first born child</programlisting>
        </example>
      </section>
    </section>

    <section>
      <title>'and'</title>

      <para>The 'and' Conditional Element is used to group together other
      Conditional Elements. The root element of the LHS is an implicit
      prefixAnd and doesn't need to be specified. Drools supports both prefix
      and infix; although prefix is the preferred option as grouping is
      implicit which avoids confusion.</para>

      <figure>
        <title>prefixAnd</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="prefixAnd.svg" format="SVG"
                       role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="prefixAnd.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <example>
        <title>prefixAnd</title>

        <programlisting>(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )
</programlisting>
      </example>

      <example>
        <title>implicit root prefixAnd</title>

        <programlisting>when
     Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType )</programlisting>
      </example>

      <para>Infix 'and' is supported along with explicit grouping with
      parenthesis, should it be needed. The '&amp;&amp;' symbol, as an
      alternative to 'and', is deprecated although it is still supported in
      the syntax for legacy support reasons.</para>

      <figure>
        <title>infixAnd</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="infixAnd.svg" format="SVG"
                       role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="infixAnd.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>infixAnd</title>

        <programlisting>Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType ) //infixAnd
(Cheese( cheeseType : type ) and (Person( favouriteCheese == cheeseType ) or Person( favouriteCheese == cheeseType  ) ) //infixAnd with grouping</programlisting>
      </example>
    </section>

    <section>
      <title>'or'</title>

      <para>The 'or' Conditional Element is used to group together other
      Conditional Elements. Drools supports both prefix and infix; although
      prefix is the preferred option as grouping is implicit which avoids
      confusion. The behaviour of the 'or' Conditional Element is different
      than the '||' connective for constraints and restrictions in field
      constraints. The engine actually has no understanding of 'or'
      Conditional Elements, instead via a number of different logic
      transformations the rule is re-written as a number of subrules; the rule
      now has a single 'or' as the root node and a subrule per logical
      outcome. Each subrule can activate and fire like any normal rule, there
      is no special behaviour or interactions between the subrules - this can
      be most confusing to new rule authors.</para>

      <figure>
        <title>prefixOr</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="orPrefix.svg" format="SVG"
                       role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="prefixOr.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>prefixOr</title>

        <programlisting>(or Person( sex == "f", age &gt; 60 )
    Person( sex == "m", age &gt; 65 )
</programlisting>
      </example>

      <para>Infix 'or' is supported along with explicit grouping with
      parenthesis, should it be needed. The '||' symbol, as an alternative to
      'or', is deprecated although it is still supported in the syntax for
      legacy support reasons.</para>

      <figure>
        <title>infixOr</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="infixOr.svg" format="SVG"
                       role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="infixOr.png" format="PNG"
                       role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>infixAnd</title>

        <programlisting>Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType ) //infixOr
(Cheese( cheeseType : type ) or (Person( favouriteCheese == cheeseType ) and Person( favouriteCheese == cheeseType  ) ) //infixOr with grouping</programlisting>
      </example>

      <para>The 'or' Conditional Element also allows for optional pattern
      binding; which means each resulting subrule will bind it's pattern to
      the pattern binding.</para>

      <example>
        <title>or with binding</title>

        <programlisting>pensioner : (or Person( sex == "f", age &gt; 60 ) 
                Person( sex == "m", age &gt; 65 ) )</programlisting>

        <para>Explicit binding on each Pattern is also allowed.</para>

        <programlisting>(or pensioner : Person( sex == "f", age &gt; 60 ) 
    pensioner : Person( sex == "m", age &gt; 65 ) )</programlisting>
      </example>

      <para>The 'or' conditional element results in multipe rule generation,
      called sub rules, for each possible logically outcome. the example above
      would result in the internal generation of two rules. These two rules
      work independently within the Working Memory, which means both can
      match, activate and fire - there is no shortcutting.</para>

      <para>The best way to think of the OR conditional element is as a
      shortcut for generating 2 additional rules. When you think of it that
      way, its clear that for a single rule there could be multiple
      activations if both sides of the OR conditional element are true.</para>
    </section>

    <section>
      <title>'eval'</title>

      <figure>
        <title>eval</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="eval.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="eval.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Eval is essentially a catch all which allows any semantic code
      (that returns a primitive primitive boolean) to be executed. This can
      refer to variables that were bound in the LHS of the rule, and functions
      in the rule package. Over use of eval reduces the declarativess of your
      rules and can result in a poor performing engine. While 'evals' can be
      used anywhere in the Pattern the best practice is to add it as the last
      conditional element in the LHS of a rule. </para>

      <para>Evals cannot be indexed and thus are not as optimal as using Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints. </para>

      <para>For folks who are familiar with Drools 2.x lineage, the old Drools
      paramater and condition tags are equivalent to binding a variable to an
      appropriate type, and then using it in an eval node.</para>

      <example>
        <title>eval</title>

        <programlisting>p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
eval( isValid(p1, p2) ) //this is how you call a function in the LHS - a function called "isValid"</programlisting>
      </example>
    </section>

    <section>
      <title>'not'</title>

      <figure>
        <title>not</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="not.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="not.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>'not' is first order logic's Existential Quantifier and checks for
      the non existence of something in the Working Memory. Brackets are
      optional. Think of 'not' as meaning "there must be none of...".</para>

      <example>
        <title>No Busses</title>

        <programlisting>not Bus()</programlisting>
      </example>

      <example>
        <title>No red Busses</title>

        <programlisting>not Bus(color == "red")
not ( Bus(color == "red", number == 42) ) //brackets are optional
not ( Bus(color == "red") and Bus(color == "blue")) // not with nested 'and' infix used here as ony two patterns</programlisting>
      </example>
    </section>

    <section>
      <title>'exists'</title>

      <figure>
        <title>exists</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="exists.svg" format="SVG" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="exists.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>'exists' is first order logic's Existential Quantifier and checks
      for the existence of something in the Working Memory. Think of exist as
      meaning "at least one..". It is different from just having the Pattern
      on its own; which is more like saying "for each one of...". if you use
      exist with a Pattern, then the rule will only activate once regardless
      of how much data there is in working memory that matches that
      condition.</para>

      <example>
        <title>Atleast one Bus</title>

        <programlisting>exists Bus()</programlisting>
      </example>

      <example>
        <title>Atleast one red Bus</title>

        <programlisting>exists Bus(color == "red")
exists ( Bus(color == "red", number == 42) ) //brackets are optional
exists ( Bus(color == "red") and Bus(color == "blue")) // not with nested 'and' infix used here as ony two patterns</programlisting>
      </example>
    </section>
  </section>

  <section>
    <title>The Right Hand Side (then)</title>

    <para>The Right Hand Side (RHS) is a common name for the consequence or
    action part of the rule; this part should contain a list of actions to be
    executed.It is bad practice to use imperative or conditoinal code in the
    RHS of a rule; as a rule should be atomic in nature - "when this, then do
    this", not "when this, maybe do this". The RHS part of a rule should also
    be kept small, thus keeping it declarative and readable. If you find you
    need imperative and/or conditional code in the RHS, then maybe you should
    be breaking that rule down into multiple rules. The main purpose of the
    RHS is to insert, retractor modify working memory data. To assist with
    there there are a few convenience methods you can use to modify working
    memory; without having to first reference a working memory
    instance.</para>

    <para>"update(object, handle);" will tell the engine that an object has
    changed (one that has been bound to something on the LHS) and rules may
    need to be reconsidered.</para>

    <para>"insert(new Something());" will place a new object of your creation
    in working memory.</para>

    <para>"insertLogical(new Something());" is similar to insert, but the
    object will be automatically retracted when there are no more facts to
    support the truth of the currently firing rule.</para>

    <para>"retract(handle);" removes an object from working memory.</para>

    <para>These convenience methods are basically macros that provide short
    cuts to the KnowldgeHelper instance (refer to the KnowledgeHelper
    interface for more advanced operations). The KnowledgeHelper interface is
    made available to the RHS code block as a variable called "drools". If you
    provide "Property Change Listeners" to your java beans that you are
    inserting into the engine, you can avoid the need to call "update" when
    the object changes.</para>
  </section>

  <section>
    <title>A note on auto boxing/unboxing and primitive types</title>

    <para>Drools attempts to preserve numbers in their primitive or object
    wrappter form, so a variable bound to an int primtive when used in a code
    block or expression will no longer need manual unboxing; unlike Drools 3.0
    where all primitives was autoboxed, requiring manual unboxing. A variable
    bound to an object wrapper will remain as an object; the existing jdk1.5
    and jdk5 rules to handling auto boxing/unboxing apply in this case. When
    evaluating field constraints the system attempts to coerce one of the
    values into a comparable format; so a primitive is comparable to an object
    wrapper.</para>
  </section>
</section>