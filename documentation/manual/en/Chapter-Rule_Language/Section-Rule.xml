<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="rule.svg" format="SVG" role="" />
      </imageobject>

      <imageobject>
        <imagedata align="center" fileref="rule.png" format="PNG" role="" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>The Rule construct is where is clearly the most important construct.
  Rules are of the form "IF" something "THEN" action (of course we chose the
  keywords "when" and "then") - in the style of production rules.</para>

  <para>A rule must have a name, and be a unique name for a rule package. If a
  rule name is to have spaces, then it will need to be in double quotes (its
  best to always use double quotes).</para>

  <para>Attributes are optional, and are described below (they are best kept
  as one per line).</para>

  <para>The LHS of the rule follows the "when" keyword (ideally on a new
  line), similarly the RHS follows the "then" keyword (ideally on a newline).
  The rule is terminated by the keyword "end". Rules cannot be nested of
  course.</para>

  <section>
    <title>Left Hand Side</title>

    <para>The Left Hand Side (LHS) is a common name for the conditional part
    of the rule.</para>

    <para>To interpret the following diagram, refer to the sections below for
    the details.</para>

    <figure>
      <title>Left Hand Side</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="lhs.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="lhs.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>pattern</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="pattern.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="pattern.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>The Right Hand Side</title>

    <para>The Right Hand Side (RHS) is a common name for the consequence or
    action part of the rule. The purpose of the right hand side is to retract
    or add facts to working memory, and also invoke arbitary actions specific
    to your application. In practical terms, the RHS is a block of code that
    is executed when the rule fires.</para>

    <para>There are a few convenience methods you can use to modify working
    memory:</para>

    <para>"modify(obj);" will tell the engine that an object has changed (one
    that has been bound to something on the LHS) and rules may need to be
    reconsidered.</para>

    <para>"assert(new Something());" will place a new object of your creation
    in working memory.</para>

    <para>"assertLogical(new Something());" is similar to assert, but the
    object will be automatically retracted when there are no more facts to
    support the truth of the currently firing rule.</para>

    <para>"retract(obj);" removes an object from working memory.</para>

    <para>These convenience methods are basically macros that provide short
    cuts to the KnowldgeHelper instance (refer to the KnowledgeHelper
    interface for more advanced operations). The KnowledgeHelper interface is
    made available to the RHS code block as a variable called "drools". If you
    provide "Property Change Listeners" to your java beans that you are
    asserting into the engine, you can avoid the need to call "modify" when
    the object changes.</para>
  </section>

  <section>
    <title>Rule Attriutes</title>

    <para />

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="rule_attributes.svg" format="SVG" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="rule_attributes.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>no-loop</title>

      <para>default value : false</para>

      <para>type : Boolean</para>

      <para>When the Rule's consequence modifies a fact it may cause the Rule
      to activate again, causing recursion. Setting no-loop to true means the
      attempt to create the Activation will be ignored.</para>
    </section>

    <section>
      <title>salience</title>

      <para>default value : 0</para>

      <para>type : integer</para>

      <para>Each rule has a salience attribute that can be assigned an Integer
      number, defaults to zero, the Integer and can be negative or positive.
      Salience is a form of priority where rules with higher salience values
      are given higher priority when ordered in the Activation queue.</para>
    </section>

    <section>
      <title>agenda-group</title>

      <para>default value : MAIN</para>

      <para>type : String</para>

      <para>Agenda group's allow the user to partition the Agenda providing
      more execution control. Only rules in the focus group are allowed to
      fire.</para>
    </section>

    <section>
      <title>auto-focus</title>

      <para>default value false</para>

      <para>type : Boolean</para>

      <para>When a rule is activated if the <literal>auto-focus value is true
      and the Rule's </literal> <literal>agenda-group</literal> does not have
      focus then it is given focus, allowing the rule to potentially
      fire.</para>
    </section>

    <section>
      <title>activation-group</title>

      <para>default value N/A</para>

      <para>type : String</para>

      <para>Rules that belong to the same named activation-group will only
      fire exclusively. In other words, the first rule in an activation-group
      to fire will cancel the other rules activations (stop them from firing).
      The Activtion group attribute is any string, as long as the string is
      identical for all the rules you need to be in the one group.</para>

      <para>NOTE: this used to be called Xor group, but technically its not
      quite an Xor, but you may hear people mention Xor group, just swap that
      term in your mind with activation-group.</para>
    </section>

    <section>
      <title>duration</title>

      <para>default value : no default value</para>

      <para>type : long</para>

      <para />
    </section>

    <example>
      <title>Some attribute examples</title>

      <programlisting>rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</programlisting>
    </example>
  </section>

  <section>
    <title>Column</title>

    <figure>
      <title>Column</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="column.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="column.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Column</title>

      <programlisting>Cheese( )
Cheese( type == "stilton", price &lt; 10 )</programlisting>
    </example>

    <para>A Rule consists of Field Constraints on one or more Object Types.
    Internally each matched Object Type instance is stored in an array. If we
    match against three objects Person, Person and Pet we have a three element
    array; in Drools we refer to this list of Facts as a Tuple - each element
    in the array is a Column. Each Object Type instance is filtered through
    zero or more Field Constraints - the term Column is used to refer to this
    list of constraints on the Object type. The first example has no
    constraints and will match any Cheese instance in the Working Memory,
    regardless of its field values. The second case refers to two Literal
    Field Constraints on against instances of a Cheese object - they are
    seperated by a comma, which implicitly means "and".</para>

    <figure>
      <title>Column</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="bound_column.svg" format="SVG"
                     role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="bound_column.png" format="PNG"
                     role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Bound Column</title>

      <programlisting>cheapStilton : Cheese( type == "stilton", price &lt; 10 )</programlisting>
    </example>

    <para>This is similar to the previous case, but in this case we are
    binding a variable to that instance of Cheese that the rule engine will
    match. This means you can use cheapStilton in another condition, or
    perhaps in the consequence part of the rule. You can also eat it, but I
    wouldn't.</para>

    <section>
      <title>Field Constraints</title>

      <para>Field constraints place constraints on the Fact objects for the
      rule engine to match/select out of working memory. They work
      comparing/evaluating "field" values from the fact object
      instances.</para>

      <para>A "field" is not a field in the sense of a public or private
      member of a class. A field is an accessible method. If your model
      objects follow the java bean pattern, then fields are accessed via
      "getXXX" or "isXXX" methods (these are methods that take no arguments,
      and return something). You can access fields either by using the
      bean-name convention (so "getType" can be accessed as "type") or by
      specifying the whole method name (without any brackets).</para>

      <para>For example, refering to our Cheese class, the following are
      equivalent: Cheese(type == ...), and Cheese(getType == ...). This means
      that you can use model objects that aren't strictly java beans. However,
      make sure that you are accessing methods that take no parameters, and
      are infact "accessors" (as in, they don't change the state of the object
      in a way that may effect the rules - remember that the rule engine
      effectively caches the results of its matching inbetween invocations to
      make it faster).</para>

      <para>Note that if primitive types are used for a field, Drools will
      autobox them to their corresponding object types (even if you are using
      java 1.4) - however on java 1.4 there is currently no auto-unboxing when
      inside code expressions or blocks. On the whole, it is probably best to
      use the non primitive types in the model objects you are using in your
      rules. If you use Java 5, then you get the best of both worlds (you can
      let the compiler autobox for you - much neater).</para>

      <section>
        <title>Operators</title>

        <figure>
          <title>Operators</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="operator.svg" format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="operator.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>There are a number of <indexterm>
            <primary>operatorst</primary>
          </indexterm>opreators that can be used with the various <indexterm>
            <primary>Field Constraint</primary>
          </indexterm>Field Constraints. Valid operators are dependent on the
        field type. Generally they are self explanatory based on the type of
        data: for instance, for date fields, "&lt;" means "before" and so on.
        "Matches" is only applicable to string fields, "contains" and
        "excludes" is only applicable to Collection type fields.</para>
      </section>

      <section>
        <title>Literal Constraints</title>

        <para>The most basic of Field Constraints is the <indexterm>
            <primary>Literal Constraint</primary>
          </indexterm>Literal Constraint which allows the user to constrain a
        field to a given value.</para>

        <para>A note on nulls: you can do checks against fields that are or
        maybe null, using == and != as you would expect, and the literal
        "null" keyword, like: Cheese(type != null). Literal Constraints,
        specifically the '==' operator, provide for very fast execution as we
        can use hasing to improve performance.</para>

        <figure>
          <title>Literal Constraints</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="literal_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="literal_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <simplesect>
          <title>Numeric</title>

          <para>All standard java numeric primitives are supported</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>

            <listitem>
              <para>&gt;</para>
            </listitem>

            <listitem>
              <para>&lt;</para>
            </listitem>

            <listitem>
              <para>&gt;=</para>
            </listitem>

            <listitem>
              <para>&lt;=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Numeric Literal Constraint</title>

            <programlisting>Cheese( quantity == 5 )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Date</title>

          <para>Currently only "dd-mmm-yyyy" date format is supported by
          default. You can customise this by providing an alternative date
          format mask as a System property ("drools.dateformat" is the name of
          the property). If more control is required, use the predicate
          constraint.</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>

            <listitem>
              <para>&gt;</para>
            </listitem>

            <listitem>
              <para>&lt;</para>
            </listitem>

            <listitem>
              <para>&gt;=</para>
            </listitem>

            <listitem>
              <para>&lt;=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Date Literal Constraint</title>

            <programlisting>Cheese( bestBefore &lt; "27-Oct-2007" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>String</title>

          <para>Any valid Java String is allowed.</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>String Literal Constraint</title>

            <programlisting>Cheese( type == "stilton" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Boolean</title>

          <para>only true or false can be used. 0 and 1 are not recognised,
          nor is <literal>Cheese ( smelly )</literal> is not allowed</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>true</para>
            </listitem>

            <listitem>
              <para>false</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Boolean Literal Constraint</title>

            <programlisting>Cheese( smelly == true )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Matches Operator</title>

          <para>Any valid Java <indexterm>
              <primary>regular expression</primary>
            </indexterm>Regular Expression can be used to match String
          fields.</para>

          <example>
            <title>Regular Expression Constraint</title>

            <programlisting>Cheese( type matches "(Buffulo)?\\S*Mozerella" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Contains Operator</title>

          <para><literal>'contains' </literal>is a special operator that can
          be used to check if a field's <indexterm>
              <primary>Collection</primary>
            </indexterm>Collection contains an object.</para>

          <example>
            <title>Literal Cosntraints with Collections</title>

            <programlisting>CheeseCounter( cheeses contains "stilton" )
CheeseCounter( cheeses excludes "chedder" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Excludes Operator</title>

          <para><literal>'excludes' </literal>is a special operator that can
          be used to check if a field's <indexterm>
              <primary>Collection</primary>
            </indexterm>Collection does not contains an object.</para>

          <example>
            <title>Literal Cosntraints with Collections</title>

            <programlisting>CheeseCounter( cheeses excludes "cheddar" )</programlisting>
          </example>
        </simplesect>
      </section>

      <section>
        <title>Bound Variable Constraint</title>

        <figure>
          <title>Bound Variable Declaration</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="boundvariable_constraints.svg" format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center"
                         fileref="boundvariable_constraints.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Variables can be bound to Facts and their Fields and then used
        in subsequent Field Constraints. A bound variable is called a
        <indexterm>
            <primary>declaration</primary>
          </indexterm>Declaration. Declarations cannot be used with
        <literal>'matches'</literal>, although it works with
        <literal>'contains'</literal>. Valid operators are determined by the
        type of the field being constrained. Bound Variables, specifically the
        '==' and '=!' operators, provide for very fast execution as we can use
        hasing to improve performance.</para>

        <example>
          <title>Bound Field using '==' operator</title>

          <programlisting>Person( likes : favouriteCheese )
Cheese( type == likes )</programlisting>

          <para>'likes' is our variable, our Declaration, that is bound to the
          favouriteCheese field for any matching Person instance and is used
          to constrain the type of Cheese in the following Column. Any valid
          java variable name can be used, including '$'; which you will often
          see used to help differentiate declarations from fields. The exampe
          below shows a declaration bound to the Columns Object Type instance
          itself and used with a 'contains' operator, note the optional use of
          '$' this time.</para>
        </example>

        <example>
          <title>Bound Fact using 'contains' operator</title>

          <programlisting>$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</programlisting>
        </example>
      </section>

      <section>
        <title>Predicate Constraints</title>

        <figure>
          <title>Predicate expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="predicate_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="predicate_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>A <indexterm>
            <primary>Predicate</primary>
          </indexterm>Predicate constraint can use any valid Java expression
        as long as it evaluated to a primitive boolean - avoid using any
        Drools keywords as Declaration identifiers. Previously bound
        declarations can be used in the expression. Functions used in a
        Predicate Constraint must return time constant results. All bound
        primitive declarations are boxed, there is currently no auto-unboxing
        (if you use java 5, this is all automatic).</para>

        <para>This example will find all pairs of male/femal people where the
        male is 2 years older than the female.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( boyAge : age -&gt; ( girlAge.intValue() == boyAge.intValue() + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>

      <section>
        <title>Return Value Constraints</title>

        <figure>
          <title>Return Value expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="returnvalue_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="returnvalue_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>A <indexterm>
            <primary>Return Value</primary>
          </indexterm>Return Value constraint can use any valid Java
        expression as long as it returns an object, it cannot return
        primitives - avoid using any Drools keywords as Declaration
        identifiers. Functions used in a Return value Constraint must return
        time constant results. Previously bound declarations can be used in
        the expression. All bound primitive declarations are boxed, there is
        currently no auto-unboxing. The returned value must be boxed if its a
        primitive..</para>

        <para>Like the Predicate example this will find all pairs of
        male/femal people where the male is 2 years older than the female.
        Notice here we didn't have to bind the boyAge, making it a little
        simpler to read.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( age == ( new Integer(girlAge.intValue() + 2) ), sex = 'M' )
</programlisting>
        </example>
      </section>
    </section>
  </section>

  <section>
    <title>Conditional Elements</title>

    <para>Conditional elements work on one or more Columns (which were
    described above). The most common one is "and" which is implicit when you
    have multiple Columns in the LHS of a rule that are not connected in
    anyway. Note that an 'and' cannot have a leading declaration binding like
    'or' - this is obvious when you think about it. A declaration can only
    reference a single Fact, when the 'and' is satisfied it matches more than
    one fact - which fact would the declaration bind to?</para>

    <section>
      <title>'and'</title>

      <figure>
        <title>and</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="and.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="and.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : and, or, not, exists, column</para>

      <example>
        <title>Column</title>

        <programlisting>Cheese( cheeseType : type ) &amp;&amp; Person( favouriteCheese == cheeseType )
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )</programlisting>
      </example>
    </section>

    <section>
      <title>'or'</title>

      <figure>
        <title>or</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="or.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="or.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : and, or, not, exists, column</para>

      <example>
        <title>or</title>

        <programlisting>Person( sex == "f", age &gt; 60 ) || Person( sex == "m", age &gt; 65 )
Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 )
</programlisting>
      </example>

      <figure>
        <title>or</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="or_with_binding.svg"
                       format="SVG" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="or_with_binding.png"
                       format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>or with binding</title>

        <programlisting>pensioner : Person( sex == "f", age &gt; 60 ) || pensioner : Person( sex == "m", age &gt; 65 ) 
pensioner : ( Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 ) )</programlisting>
      </example>

      <para>The 'or' conditional element results in multipe rule generation,
      called sub rules, for each possible logically outcome. the examples
      above would result in the internal generation of two rules. These two
      rules work independantly within the Working Memory, which means both can
      match, activate and fire - there is no shortcutting. Care must be taken
      when binding with an "or" conditional element, as incorrect use may
      yield apparently unpredictable results - if you bind a field on the
      first Person of the 'or' and not the other and then try to access that
      binding in a later Field Constraint or Consequence you cannot gaurantee
      that decalration will be available for that sub rule. In such a scenario
      you referred to a variable that is bound to a column that does not exist
      in a given activation - giving null pointer exceptions, and the
      associated headaches.</para>

      <para>The best way to think of the OR conditional element is as a
      shortcut for generating 2 additional rules. When you think of it that
      way, its clear that for a single rule there could be multiple
      activations if both sides of the OR conditional element are true.</para>
    </section>

    <section>
      <title>'eval'</title>

      <figure>
        <title>eval</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="eval.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="eval.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : none</para>

      <para>Eval is essentially a catch all which allows any semantic code
      (that returns a primitive primitive boolean) to be executed. This can
      refer to variables that were bound in the LHS of the rule, and functions
      in the rule package. An eval should be the last conditional element in
      the LHS of a rule. You can have multiple evals in a rule. Generally you
      would combine them with some column constraints.</para>

      <para>Evals cannot be indexed and thus are not as optimal as using Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints. An Eval will be checked each time if all the other
      conditions in the rules are met.</para>

      <para>For folks who are familiar with Drools 2.x lineage, the old Drools
      paramater and condition tags are equivalent to binding a variable to an
      appropriate type, and then using it in an eval node.</para>

      <example>
        <title>eval</title>

        <programlisting>p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
eval( isValid(p1, p2) ) //this is how you call a function in the LHS - a function called "isValid"</programlisting>
      </example>
    </section>

    <section>
      <title>'not'</title>

      <figure>
        <title>not</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="not.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="not.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children: Column</para>

      <para>'not' is first order logic's Existential Quantifier and checks for
      the non existence of something in the Working Memory. Currently only
      Columns may be nested in a 'not' but future versions of will allow 'and'
      and 'or' to be nested.</para>

      <example>
        <title>No Busses</title>

        <programlisting>not Bus()</programlisting>
      </example>

      <example>
        <title>No red Busses</title>

        <programlisting>not Bus(color == "red")
not ( Bus(color == "red", number == 42) ) //brackets are optional</programlisting>
      </example>
    </section>

    <section>
      <title>'exists'</title>

      <figure>
        <title>exists</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="exists.svg" format="SVG" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="exists.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children: Column</para>

      <para>'exists' is first order logic's Existential Quantifier and checks
      for the existence of something in the Working Memory. Think of exist as
      meaning "at least one..". It is different from just having the Column on
      its own. If you had the column on its on, its kind of like saying "for
      each one of...". if you use exist with a Column, then the rule will only
      activate once regardless of how much data there is in working memory
      that matches that condition. </para>

      <para>Currently only Columns may be nested in a 'exists' but future
      versions of will allow 'and' and 'or' to be nested.</para>

      <example>
        <title>Atleast one Bus</title>

        <programlisting>exists Bus()</programlisting>
      </example>

      <example>
        <title>Atleast one red Bus</title>

        <programlisting>exists Bus(color == "red")</programlisting>
      </example>
    </section>

    <section>
      <title>'group'</title>

      <figure>
        <title>group</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="group.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="group.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Grouping is similar to using parentheses in algebra, it makes the
      order of operations explicit.</para>

      <example>
        <title>Example of groups</title>

        <programlisting>...
( 
  Message( status == Message.HELLO ) and Message(message != null) 
      or Message(status == null)  
)
...</programlisting>
      </example>
    </section>

    <example>
      <title>A rule example</title>

      <programlisting>rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</programlisting>
    </example>
  </section>

  <section>
    <title>A note on autoboxing and primitive types</title>

    <para>Java 5 supports autoboxing and unboxing between primitives of
    appropriate types. This makes for very convenient and easy to read code.
    However, as drools runs in J2SE 1.4 as well, we can't rely on this. Thus
    we have to autobox at times. Fields that are referred to are autoboxed in
    the corresponding object type automatically (if they are already an
    object, then there is no change). However, it is important to note that
    they are not "unboxed" automatically. Thus if you bind to a field that is
    an "int" in your object model, it will behave like an Object in the rule
    (ie predicates, return value constraints and the RHS).</para>

    <para>As a general rule, if possible, make your fields object types (at
    least until java 5), or at least think of your fields as object types even
    if they are not to start with). Another special note, is that for return
    value constraints, the return value snippet of code must return an Object
    (not a primitive). Now, I bet you can't wait for Java 5 to be the minimum
    ! The fact that not quite *everything* in java is an object causes
    headaches like this (keep those tablets handy).</para>
  </section>
</section>