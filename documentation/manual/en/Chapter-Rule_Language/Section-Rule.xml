<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="rule.svg" format="SVG" role="" />
      </imageobject>

      <imageobject>
        <imagedata align="center" fileref="rule.png" format="PNG" role="" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>A rule specifies that "when" a particular set of conditions occur,
  specified in the Left Hand Side (LHS), then do this, which is specified as a
  list of actions in the Right Hand Side (RHS). A common question from users
  is "why use when instead of if". "when" was chosen over "if" becuase "if" is
  normally part of a procedural execution flow, where at a specific point in
  time it checks the condition. Where as "when" indicates it's not tied to a
  specific evaluation sequence or point in time, at any time during the life
  time of the engine "when" this occurs, do that. Rule</para>

  <para>A rule must have a name, and be a unique name for the rule package. If
  you define a rule twice in the same DRL it produce an error while loading.
  If you add a DRL that has includes a rule name already in the package, it
  will replace the previous rule. If a rule name is to have spaces, then it
  will need to be in double quotes (its best to always use double
  quotes).</para>

  <para>Attributes are optional, and are described below (they are best kept
  as one per line).</para>

  <para>The LHS of the rule follows the "when" keyword (ideally on a new
  line), similarly the RHS follows the "then" keyword (ideally on a newline).
  The rule is terminated by the keyword "end". Rules cannot be nested of
  course.</para>

  <example>
    <title>Rule Syntax Overview Example</title>

    <programlisting>rule "&lt;name&gt;"
    &lt;attribute&gt;*
when
    &lt;conditional element&gt;*
then
    &lt;action&gt;*
end</programlisting>
  </example>

  <example>
    <title>A rule example</title>

    <programlisting>rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age &gt; 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end</programlisting>
  </example>

  <section>
    <title>Rule Attriutes</title>

    <para>Rule attributes provide a declarative way to influence the behaviour
    of the rule, some are quite simple, while others are part of complex sub
    systems; such as ruleflow. To get the most from Drools you should make
    sure you have a proper understanding of each attribute.</para>

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="rule_attributes.svg" format="SVG" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="rule_attributes.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>no-loop</title>

      <para>default value : false</para>

      <para>type : Boolean</para>

      <para>When the Rule's consequence modifies a fact it may cause the Rule
      to activate again, causing recursion. Setting no-loop to true means the
      attempt to create the Activation for the current set of data will be
      ignored.</para>
    </section>

    <section>
      <title>salience</title>

      <para>default value : 0</para>

      <para>type : integer</para>

      <para>Each rule has a salience attribute that can be assigned an Integer
      number, defaults to zero, the Integer and can be negative or positive.
      Salience is a form of priority where rules with higher salience values
      are given higher priority when ordered in the Activation queue.</para>
    </section>

    <section>
      <title>agenda-group</title>

      <para>default value : MAIN</para>

      <para>type : String</para>

      <para>Agenda group's allow the user to partition the Agenda providing
      more execution control. Only rules in the focus group are allowed to
      fire.</para>
    </section>

    <section>
      <title>auto-focus</title>

      <para>default value false</para>

      <para>type : Boolean</para>

      <para>When a rule is activated if the <literal>auto-focus value is true
      and the Rule's </literal> <literal>agenda-group</literal> does not have
      focus then it is given focus, allowing the rule to potentially
      fire.</para>
    </section>

    <section>
      <title>activation-group</title>

      <para>default value : N/A</para>

      <para>type : String</para>

      <para>Rules that belong to the same named activation-group will only
      fire exclusively. In other words, the first rule in an activation-group
      to fire will cancel the other rules activations (stop them from firing).
      The Activtion group attribute is any string, as long as the string is
      identical for all the rules you need to be in the one group.</para>

      <para>NOTE: this used to be called Xor group, but technically its not
      quite an Xor, but you may hear people mention Xor group, just swap that
      term in your mind with activation-group.</para>
    </section>

    <section>
      <title>dialect</title>

      <para>default value : as specified by the package</para>

      <para>type : String</para>

      <para>The dialect species the language to be used for any code
      expressions in the LHS or the RHS code block. Currently two dialects are
      available, Java and MVEL. While the dialect can be specified at the
      package level, this attribute allows the package definition to be
      overriden.</para>
    </section>

    <section>
      <title>date-effective</title>

      <para>default value : N/A</para>

      <para>type : String, which contains a Date/Time definition</para>

      <para>A rule can only activate if the current date and time is afer
      date-effective attribute.</para>
    </section>

    <section>
      <title>date-exptires</title>

      <para>default value : N/A</para>

      <para>type : String, which contains a Date/Time definition</para>

      <para>A rule cannot activate if the current date and time is afer
      date-expires attribute.</para>
    </section>

    <section>
      <title>duration</title>

      <para>default value : no default value</para>

      <para>type : long</para>

      <para>The duration dictates that the rule will fire after a specified
      duration, if it is still true.</para>
    </section>

    <example>
      <title>Some attribute examples</title>

      <programlisting>rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
</programlisting>
    </example>
  </section>

  <section>
    <title id="RuleLanguage-LHS">Left Hand Side (when)</title>

    <para>The Left Hand Side (LHS) is a common name for the conditional part
    of the rule. It consists of zero or more Conditional Elements. If the LHS
    is left empty it is re-written as eval(true), which means the rule is
    always true, and will be activated with a new Working Memory session is
    created.</para>

    <figure>
      <title>Left Hand Side</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="lhs.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="lhs.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Rule Syntax Overview Example</title>

      <programlisting>rule "no CEs"
when
then
    &lt;action&gt;*
end</programlisting>

      <para>Is internally re-written as:</para>

      <programlisting>rule "no CEs"
when
    eval( true )
then
    &lt;action&gt;*
end</programlisting>
    </example>

    <section id="RuleLanguage-ConditionalElements">
      <title>Conditional Elements</title>

      <para>Conditional elements work on one or more Columns (which were
      described above). The most common one is "and" which is implicit when
      you have multiple Columns in the LHS of a rule that are not connected in
      anyway. Note that an 'and' cannot have a leading declaration binding
      like 'or' - this is obvious when you think about it. A declaration can
      only reference a single Fact, when the 'and' is satisfied it matches
      more than one fact - which fact would the declaration bind to?</para>

      <section>
        <title>Pattern</title>

        <para>The Pattern element is the most important Conditional Element.
        The entity relationship diagram below provides an overview of the
        various parts that make up the Pattern's constraints and how they work
        together; each is then covered in more detail with rail road diagrams
        and examples.</para>

        <figure>
          <title>Pattern Entity Relationship Diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="patternER.svg" format="SVG"
                         role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="patternER.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>At the top of the ER diagram you can see that the pattern
        consists of zero or more constriants and has an optional pattern
        binding. The rail road diagram below shows the syntax for this.</para>

        <figure>
          <title>Pattern</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="pattern.svg" format="SVG"
                         role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="pattern.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>At the simplest, with no constraints, it simply matches against
        a type, in the following case the type is "Cheese". This means the
        pattern will match against all Cheese objects in the Working
        Memory.</para>

        <example>
          <title>Pattern</title>

          <programlisting>Cheese( )</programlisting>
        </example>

        <para>To be able to refer to the matched object use a pattern binding
        variable such as '$c'. While this example variable is prefixed with a
        $ symbol, it is optional, but can be useful in complex rules as it
        helps to more easily differentiation between variables and
        fields.</para>

        <example>
          <title>Pattern</title>

          <programlisting>$c : Cheese( )</programlisting>
        </example>

        <para>Inside of the Pattern parenthesis is where all the action
        happens. A constraint can be either a Field Constraint, Inline Eval
        (called a predicate in 3.0) or a Constraint Group. Constraints can be
        seperated by the following symboles ',', '&amp;&amp;' or '||'.</para>

        <figure>
          <title>Constraints</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="constraints.svg" format="SVG"
                         role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="constraints.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure>
          <title>Constraint</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="constraint.svg" format="SVG"
                         role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="constraint.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure>
          <title>Group Constraint</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="constraintGroup.svg"
                         format="SVG" role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="constraintGroup.png"
                         format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>',' and '&amp;&amp;' when used without '||' are equivalent;. ','
        is provided as a less verbose '&amp;&amp;' connective for more simple
        field constraints.</para>

        <example>
          <title>Equivalent connectives</title>

          <programlisting>Cheese( type == "stilton", price &lt; 10 ) // valid
Cheese( type == "stilton" &amp;&amp; price &lt; 10 ) valid</programlisting>
        </example>

        <para>However only '&amp;&amp;' can be used with '||'.</para>

        <example>
          <title>Not Equivalent connectives</title>

          <programlisting>Cheese( type == "stilton", price &lt; 10 || age == "mature" ) // invalid
Cheese( type == "stilton" &amp;&amp; price &lt; 10 || age == "mature") // valid</programlisting>
        </example>

        <para>Constraints can be grouped using parenthesis; notice from the
        railroad and the ER diagram that this provides a recursive nature to
        the use of constraints in a Pattern.</para>

        <example>
          <title>Grouping with Parenthesis</title>

          <programlisting>Cheese( type == "stilton", ( price &lt; 10 || age == "mature" ) ) // valid
Cheese( type == "stilton" &amp;&amp; ( price &lt; 10 || age == "mature" ) ) // valid</programlisting>
        </example>

        <section>
          <title>Field Constraints</title>

          <para>A Field constraint specifies a restriction to be used on a
          field name; the field name can have an optional variable
          binding.</para>

          <figure>
            <title>fieldConstraint</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="fieldConstraint.svg"
                           format="SVG" role="" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="fieldConstraint.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>There are three types of restrictions; Single Value
          Restriction, Compount Value Restriction and Multi
          Restrictoin.</para>

          <figure>
            <title>restriction</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="restriction.svg"
                           format="SVG" role="" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="restriction.png"
                           format="PNG" role="" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>A field is an accessible method on the object. If your model
          objects follow the java bean pattern, then fields are exposed using
          "getXXX" or "isXXX" methods (these are methods that take no
          arguments, and return something). You can access fields either by
          using the bean-name convention (so "getType" can be accessed as
          "type").</para>

          <para>For example, refering to our Cheese class, the following :
          Cheese(type == ...) uses the getType() method on the a cheese
          instance. You can also access non getter methods, like "toString()"
          on the Object for instance (in which case, you do Cheese(toString ==
          ..) - you use the full name of the method with correct
          capitalisation, but not brackets). Do please make sure that you are
          accessing methods that take no parameters, and are in-fact
          "accessors" (as in, they don't change the state of the object in a
          way that may effect the rules - remember that the rule engine
          effectively caches the results of its matching inbetween invocations
          to make it faster).</para>

          <section>
            <title>JavaBeans as facts</title>

            <para>A field is an accessible method on the object. If your model
            objects follow the java bean pattern, then fields are exposed
            using "getXXX" or "isXXX" methods (these are methods that take no
            arguments, and return something). You can access fields either by
            using the bean-name convention (so "getType" can be accessed as
            "type") - we use the standard jdk Introspector class to do this
            mapping.</para>

            <para>For example, refering to our Cheese class, the following :
            Cheese(type == ...) uses the getType() method on the a cheese
            instance. If a field name cannot be found it will resort to
            calling the name as a no argument method; "toString()" on the
            Object for instance can be used with Cheese(toString == ..) - you
            use the full name of the method with correct capitalisation, but
            not brackets. Do please make sure that you are accessing methods
            that take no parameters, and are in-fact "accessors" (as in, they
            don't change the state of the object in a way that may effect the
            rules - remember that the rule engine effectively caches the
            results of its matching inbetween invocations to make it
            faster).</para>
          </section>

          <section>
            <title>Values</title>

            <para>The field constraints can take a number of values; including
            literal, qualifiedIdentifier (enum), variable and
            returnValue.</para>

            <figure>
              <title>literal</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="literal.svg" format="SVG" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="literal.png" format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <figure>
              <title>qualifiedIdentifier</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="qualifiedIdentifier.svg"
                             format="SVG" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="qualifiedIdentifier.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <figure>
              <title>variable</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="identifier.svg"
                             format="SVG" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="identifier.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <figure>
              <title>returnValue</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="returnValue.svg"
                             format="SVG" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="returnValue.png"
                             format="PNG" />
                </imageobject>
              </mediaobject>
            </figure>

            <para>You can do checks against fields that are or maybe null,
            using == and != as you would expect, and the literal "null"
            keyword, like: Cheese(type != null). If a field is null the
            evaluator will not throw an expception and will only return true
            if the value is a null check.</para>
          </section>

          <section>
            <title>Single Value Restriction</title>

            <figure>
              <title>singleValueRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
                             fileref="singleValueRestriction.svg" format="SVG"
                             role="" />
                </imageobject>

                <imageobject>
                  <imagedata align="center"
                             fileref="singleValueRestriction.png" format="PNG"
                             role="" />
                </imageobject>
              </mediaobject>
            </figure>

            <section>
              <title>Operators</title>

              <figure>
                <title>Operators</title>

                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="operator.svg"
                               format="SVG" />
                  </imageobject>

                  <imageobject>
                    <imagedata align="center" fileref="operator.png"
                               format="PNG" />
                  </imageobject>
                </mediaobject>
              </figure>

              <para>Valid operators are dependent on the field type. Generally
              they are self explanatory based on the type of data: for
              instance, for date fields, "&lt;" means "before" and so on.
              "Matches" is only applicable to string fields, "contains" and
              "not contains" is only applicable to Collection type fields.
              These operators can be used with any value and coercion to the
              correct value for the evaluator will be attempted. If the field
              is of type string and numeric value is specific it will coerce
              the numeric into a string; coercion is always in favour of the
              field and not the value.</para>

              <para></para>

              <simplesect>
                <title>Matches Operator</title>

                <para>Any valid Java <indexterm>
                    <primary>regular expression</primary>
                  </indexterm>Regular Expression can be used to match String
                fields.</para>

                <example>
                  <title>Regular Expression Constraint</title>

                  <programlisting>Cheese( type matches "(Buffulo)?\\S*Mozerella" )</programlisting>
                </example>
              </simplesect>

              <simplesect>
                <title>Contains Operator</title>

                <para><literal>'contains' </literal>is a special operator that
                can be used to check if a field's <indexterm>
                    <primary>Collection</primary>
                  </indexterm>Collection contains an object.</para>

                <example>
                  <title>Literal Constraints with Collections</title>

                  <programlisting>CheeseCounter( cheeses contains "stilton" )
CheeseCounter( cheeses excludes "chedder" )</programlisting>
                </example>
              </simplesect>

              <simplesect>
                <title>not containts</title>

                <para><literal>'not contains' </literal>is a special operator
                that can be used to check if a field's <indexterm>
                    <primary>Collection</primary>
                  </indexterm>Collection does not contains an object.</para>

                <example>
                  <title>Literal Constraints with Collections</title>

                  <programlisting>CheeseCounter( cheeses not contains "cheddar" )</programlisting>
                </example>
              </simplesect>
            </section>

            <section>
              <title>Literal Restrictions</title>

              <para>Literal Restrictions using '==' operator, provide for very
              fast execution as we can index using hashing to improve
              performance.</para>

              <figure>
                <title>literalRestriction</title>

                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="literalRestriction.svg"
                               format="SVG" />
                  </imageobject>

                  <imageobject>
                    <imagedata align="center" fileref="literalRestriction.png"
                               format="PNG" />
                  </imageobject>
                </mediaobject>
              </figure>

              <simplesect>
                <title>Numeric</title>

                <para>All standard java numeric primitives are
                supported.</para>

                <example>
                  <title>Numeric Literal Restriction</title>

                  <programlisting>Cheese( quantity == 5 )</programlisting>
                </example>
              </simplesect>

              <simplesect>
                <title>Date</title>

                <para>Currently only "dd-mmm-yyyy" date format is supported by
                default. You can customise this by providing an alternative
                date format mask as a System property ("drools.dateformat" is
                the name of the property). If more control is required, use
                the predicate constraint.</para>

                <example>
                  <title>Date Literal Restriction</title>

                  <programlisting>Cheese( bestBefore &lt; "27-Oct-2007" )</programlisting>
                </example>
              </simplesect>

              <simplesect>
                <title>String</title>

                <para>Any valid Java String is allowed.</para>

                <example>
                  <title>String Literal Restriction</title>

                  <programlisting>Cheese( type == "stilton" )</programlisting>
                </example>
              </simplesect>

              <simplesect>
                <title>Boolean</title>

                <para>only true or false can be used. 0 and 1 are not
                recognised, nor is <literal>Cheese ( smelly )</literal> is not
                allowed</para>

                <example>
                  <title>Boolean Literal Restriction</title>

                  <programlisting>Cheese( smelly == true )</programlisting>
                </example>
              </simplesect>

              <simplesect>
                <title>Qualified Identifier</title>

                <para>Enums can be used as well, both jdk1.4 and jdk5 style
                enums are supported - for the later you must be executing on a
                jdk5 environment.</para>

                <example>
                  <title>Boolean Literal Restriction</title>

                  <programlisting>Cheese( smelly == SomeClass.TRUE )</programlisting>
                </example>
              </simplesect>
            </section>

            <section>
              <title>Bound Variable Restriction</title>

              <figure>
                <title>variableRestriction</title>

                <mediaobject>
                  <imageobject>
                    <imagedata align="center"
                               fileref="variableRestriction.svg" format="SVG" />
                  </imageobject>

                  <imageobject>
                    <imagedata align="center"
                               fileref="variableRestriction.png" format="PNG" />
                  </imageobject>
                </mediaobject>
              </figure>

              <para>Variables can be bound to Facts and their Fields and then
              used in subsequent Field Constraints. A bound variable is called
              a <indexterm>
                  <primary>declaration</primary>
                </indexterm>Declaration. Valid operators are determined by the
              type of the field being constrained. Bound Variable Restrictions
              using '==' operator, provide for very fast execution as we can
              index using hashing to improve performance.</para>

              <example>
                <title>Bound Field using '==' operator</title>

                <programlisting>Person( likes : favouriteCheese )
Cheese( type == likes )</programlisting>

                <para>'likes' is our variable, our Declaration, that is bound
                to the favouriteCheese field for any matching Person instance
                and is used to constrain the type of Cheese in the following
                Column. Any valid java variable name can be used, including
                '$'; which you will often see used to help differentiate
                declarations from fields. The exampe below shows a declaration
                bound to the Columns Object Type instance itself and used with
                a 'contains' operator, note the optional use of '$' this
                time.</para>
              </example>

              <example>
                <title>Bound Fact using 'contains' operator</title>

                <programlisting>$stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains $stilton )</programlisting>
              </example>
            </section>

            <section>
              <title>Return Value Constraints</title>

              <figure>
                <title>returnValueRestriction</title>

                <mediaobject>
                  <imageobject>
                    <imagedata align="center"
                               fileref="returnValueRestriction.svg"
                               format="SVG" />
                  </imageobject>

                  <imageobject>
                    <imagedata align="center"
                               fileref="returnValueRestriction.png"
                               format="PNG" />
                  </imageobject>
                </mediaobject>
              </figure>

              <para>A <indexterm>
                  <primary>Return Value</primary>
                </indexterm>Return Value constraint can use any valid Java
              expression as long as it returns an object, it cannot return
              primitives - avoid using any Drools keywords as Declaration
              identifiers. Functions used in a Return value Constraint must
              return time constant results. Previously bound declarations can
              be used in the expression. All bound primitive declarations are
              boxed, there is currently no auto-unboxing. The returned value
              must be boxed if its a primitive..</para>

              <para>Like the Predicate example this will find all pairs of
              male/femal people where the male is 2 years older than the
              female. Notice here we didn't have to bind the boyAge, making it
              a little simpler to read.</para>

              <example>
                <title>Return Value operator</title>

                <programlisting>Person( girlAge : age, sex == "F" )
Person( age == ( new Integer(girlAge.intValue() + 2) ), sex == 'M' )
</programlisting>
              </example>
            </section>
          </section>

          <section>
            <title>Compound Value Restriction</title>

            <figure>
              <title>compoundValueRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center"
                             fileref="compoundValueRestriction.svg"
                             format="SVG" role="" />
                </imageobject>

                <imageobject>
                  <imagedata align="center"
                             fileref="compoundValueRestriction.png"
                             format="PNG" role="" />
                </imageobject>
              </mediaobject>
            </figure>

            <para></para>
          </section>

          <section>
            <title>Multi Restriction</title>

            <figure>
              <title>multiRestriction</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="multiRestriction.svg"
                             format="SVG" role="" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="multiRestriction.png"
                             format="PNG" role="" />
                </imageobject>
              </mediaobject>
            </figure>

            <figure>
              <title>restrictionGroup</title>

              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="restrictionGroup.svg"
                             format="SVG" role="" />
                </imageobject>

                <imageobject>
                  <imagedata align="center" fileref="restrictionGroup.png"
                             format="PNG" role="" />
                </imageobject>
              </mediaobject>
            </figure>

            <para></para>
          </section>
        </section>

        <section>
          <title>Inline Eval Constraints</title>

          <figure>
            <title>Inline Eval Expression</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="inlineEvalConstraint.svg"
                           format="SVG" />
              </imageobject>

              <imageobject>
                <imagedata align="center" fileref="inlineEvalConstraint.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>A <indexterm>
              <primary>Predicate</primary>
            </indexterm>inline-eval constraint can use any valid dialect
          expression as long as it evaluated to a primitive boolean - avoid
          using any Drools keywords as Declaration identifiers. Any previous
          bound variable, from the current or previous pattern, can be used;
          autovivification is also used to auto create field binding
          variables. When an identifier is found that is not a current
          variable the builder looks to see if the identifier is a field on
          the current object type, if it is the field is auto created as a
          variable of the same name; this is autovivification of field
          varables inside of inline evals.</para>

          <para>This example will find all pairs of male/femal people where
          the male is 2 years older than the female; the girlAge variable is
          auto created as part of the autovivification process.</para>

          <example>
            <title>Return Value operator</title>

            <programlisting>Person( girlAge : age, sex = "F" )
Person( eval( girlAge == boyAge + 2 ), sex = 'M' )
</programlisting>
          </example>
        </section>
      </section>

      <section>
        <title>'and'</title>

        <figure>
          <title>and</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="and.svg" format="SVG" role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="and.png" format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>valid children : and, or, not, exists, column</para>

        <example>
          <title>Column</title>

          <programlisting>Cheese( cheeseType : type ) &amp;&amp; Person( favouriteCheese == cheeseType )
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )</programlisting>
        </example>
      </section>

      <section>
        <title>'or'</title>

        <figure>
          <title>or</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="or.svg" format="SVG" role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="or.png" format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>valid children : and, or, not, exists, column</para>

        <example>
          <title>or</title>

          <programlisting>Person( sex == "f", age &gt; 60 ) || Person( sex == "m", age &gt; 65 )
Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 )
</programlisting>
        </example>

        <figure>
          <title>or</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="or_with_binding.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="or_with_binding.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <example>
          <title>or with binding</title>

          <programlisting>pensioner : ( Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 ) )</programlisting>
        </example>

        <para>The 'or' conditional element results in multipe rule generation,
        called sub rules, for each possible logically outcome. the example
        above would result in the internal generation of two rules. These two
        rules work independently within the Working Memory, which means both
        can match, activate and fire - there is no shortcutting.</para>

        <para>The best way to think of the OR conditional element is as a
        shortcut for generating 2 additional rules. When you think of it that
        way, its clear that for a single rule there could be multiple
        activations if both sides of the OR conditional element are
        true.</para>
      </section>

      <section>
        <title>'eval'</title>

        <figure>
          <title>eval</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="eval.svg" format="SVG"
                         role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="eval.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>valid children : none</para>

        <para>Eval is essentially a catch all which allows any semantic code
        (that returns a primitive primitive boolean) to be executed. This can
        refer to variables that were bound in the LHS of the rule, and
        functions in the rule package. An eval should be the last conditional
        element in the LHS of a rule. You can have multiple evals in a rule.
        Generally you would combine them with some column constraints.</para>

        <para>Evals cannot be indexed and thus are not as optimal as using
        Field Constraints. However this makes them ideal for being used when
        functions return values that change over time, which is not allowed
        within Field Constraints. An Eval will be checked each time if all the
        other conditions in the rules are met.</para>

        <para>For folks who are familiar with Drools 2.x lineage, the old
        Drools paramater and condition tags are equivalent to binding a
        variable to an appropriate type, and then using it in an eval
        node.</para>

        <example>
          <title>eval</title>

          <programlisting>p1 : Parameter() 
p2 : Parameter()
eval( p1.getList().containsKey(p2.getItem()) )
eval( isValid(p1, p2) ) //this is how you call a function in the LHS - a function called "isValid"</programlisting>
        </example>
      </section>

      <section>
        <title>'not'</title>

        <figure>
          <title>not</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="not.svg" format="SVG" role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="not.png" format="PNG" role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>valid children: Column</para>

        <para>'not' is first order logic's Existential Quantifier and checks
        for the non existence of something in the Working Memory. Currently
        only Columns may be nested in a 'not' but future versions of will
        allow 'and' and 'or' to be nested.</para>

        <example>
          <title>No Busses</title>

          <programlisting>not Bus()</programlisting>
        </example>

        <example>
          <title>No red Busses</title>

          <programlisting>not Bus(color == "red")
not ( Bus(color == "red", number == 42) ) //brackets are optional</programlisting>
        </example>
      </section>

      <section>
        <title>'exists'</title>

        <figure>
          <title>exists</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="exists.svg" format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="exists.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>valid children: Column</para>

        <para>'exists' is first order logic's Existential Quantifier and
        checks for the existence of something in the Working Memory. Think of
        exist as meaning "at least one..". It is different from just having
        the Column on its own. If you had the column on its on, its kind of
        like saying "for each one of...". if you use exist with a Column, then
        the rule will only activate once regardless of how much data there is
        in working memory that matches that condition.</para>

        <para>Currently only Columns may be nested in a 'exists' but future
        versions of will allow 'and' and 'or' to be nested.</para>

        <example>
          <title>Atleast one Bus</title>

          <programlisting>exists Bus()</programlisting>
        </example>

        <example>
          <title>Atleast one red Bus</title>

          <programlisting>exists Bus(color == "red")</programlisting>
        </example>
      </section>

      <section>
        <title>'group'</title>

        <figure>
          <title>group</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="group.svg" format="SVG"
                         role="" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="group.png" format="PNG"
                         role="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Grouping is similar to using parentheses in algebra, it makes
        the order of operations explicit.</para>

        <example>
          <title>Example of groups</title>

          <programlisting>...
( 
  Message( status == Message.HELLO ) and Message(message != null) 
      or Message(status == null)  
)
...</programlisting>
        </example>
      </section>
    </section>
  </section>

  <section>
    <title>The Right Hand Side (then)</title>

    <para>The Right Hand Side (RHS) is a common name for the consequence or
    action part of the rule; this part should contain a list of actions to be
    executed.It is bad practice to use imperative or conditoinal code in the
    RHS of a rule; as a rule should be atomic in nature - "when this, then do
    this", not "when this, maybe do this". The RHS part of a rule should also
    be kept small, thus keeping it declarative and readable. If you find you
    need imperative and/or conditional code in the RHS, then maybe you should
    be breaking that rule down into multiple rules. The main purpose of the
    RHS is to insert, retractor modify working memory data. To assist with
    there there are a few convenience methods you can use to modify working
    memory; without having to first reference a working memory
    instance.</para>

    <para>"update(object, handle);" will tell the engine that an object has
    changed (one that has been bound to something on the LHS) and rules may
    need to be reconsidered.</para>

    <para>"insert(new Something());" will place a new object of your creation
    in working memory.</para>

    <para>"insertLogical(new Something());" is similar to insert, but the
    object will be automatically retracted when there are no more facts to
    support the truth of the currently firing rule.</para>

    <para>"retract(handle);" removes an object from working memory.</para>

    <para>These convenience methods are basically macros that provide short
    cuts to the KnowldgeHelper instance (refer to the KnowledgeHelper
    interface for more advanced operations). The KnowledgeHelper interface is
    made available to the RHS code block as a variable called "drools". If you
    provide "Property Change Listeners" to your java beans that you are
    inserting into the engine, you can avoid the need to call "update" when
    the object changes.</para>
  </section>

  <section>
    <title>A note on auto boxing/unboxing and primitive types</title>

    <para>Drools attempts to preserve numbers in their primitive or object
    wrappter form, so a variable bound to an int primtive when used in a code
    block or expression will no longer need manual unboxing; unlike Drools 3.0
    where all primitives was autoboxed, requiring manual unboxing. A variable
    bound to an object wrapper will remain as an object; the existing jdk1.5
    and jdk5 rules to handling auto boxing/unboxing apply in this case. When
    evaluating field constraints the system attempts to coerce one of the
    values into a comparable format; so a primitive is comparable to an object
    wrapper.</para>
  </section>
</section>