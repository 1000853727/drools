<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>Rule</title>

  <figure>
    <title>rule</title>

    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="rule.svg" format="SVG" role="" />
      </imageobject>

      <imageobject>
        <imagedata align="center" fileref="rule.png" format="PNG" role="" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>The Rule construct is where is all happens. Rules are of the form "IF"
  something "THEN" action (of course we chose the keywords "when" and "then")
  - in the style of production rules.</para>

  <para>A rule must have a name, and be a unique name for a rule package. If a
  rule name is to have spaces, then it will need to be in double quotes (its
  best to always use double quotes).</para>

  <para>Attributes are optional, and are described below (they are best kept
  as one per line).</para>

  <para>The LHS of the rule follows the "when" keyword (ideally on a new
  line), similarly the RHS follows the "then" keyword (ideally on a newline).
  The rule is terminated by the keyword "end". Rules cannot be nested of
  course.</para>

  <section>
    <title>Left Hand Side</title>

    <para>The Left Hand Side (LHS) is a common name for the conditional part
    of the rule.</para>

    <para>To interpret the following diagram, refer to the sections below for
    the details.</para>

    <figure>
      <title>Left Hand Side</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="lhs.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="lhs.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>pattern</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="pattern.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="pattern.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>The Right Hand Side</title>

    <para>The Right Hand Side (RHS) is a common name for the consequence or
    action part of the rule. The purpose of the right hand side is to retract
    or add facts to working memory, and also invoke arbitary actions specific
    to your application. In practical terms, the RHS is a block of code that
    is executed when the rule fires.</para>

    <para>There are a few convenience methods you can use to modify working
    memory:</para>

    <para>"modify(obj);" will tell the engine that an object has changed (one
    that has been bound to something on the LHS) and rules may need to be
    reconsidered.</para>

    <para>"assert(new Something());" will place a new object of your creation
    in working memory.</para>

    <para>"assertLogical(new Something());" is similar to assert, but the
    object will be automatically retracted when there are no more facts to
    support the truth of the currently firing rule.</para>

    <para>"retract(obj);" removes an object from working memory.</para>

    <para>These convenience methods are basically macros that provide short
    cuts to the KnowldgeHelper instance (refer to the KnowledgeHelper
    interface for more advanced operations). The KnowledgeHelper interface is
    made available to the RHS code block as a variable called "drools". If you
    provide "Property Change Listeners" to your java beans that you are
    asserting into the engine, you can avoid the need to call "modify" when
    the object changes.</para>
  </section>

  <section>
    <title>Rule Attriutes</title>

    <para></para>

    <figure>
      <title>rule attributes</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="rule_attributes.svg" format="SVG" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="rule_attributes.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>no-loop</title>

      <para>default value : false</para>

      <para>type : Boolean</para>

      <para>When the Rule's consequence modifies a fact it may cause the Rule
      to activate again, causing recursion. Setting no-loop to true means the
      attempt to create the Activation will be ignored.</para>
    </section>

    <section>
      <title>salience</title>

      <para>default value : 0</para>

      <para>type : integer</para>

      <para>Each rule has a salience attribute that can be assigned an Integer
      number, defaults to zero, the Integer and can be negative or positive.
      Salience is a form of priority where rules with higher salience values
      are given higher priority when ordered in the Activation queue.</para>
    </section>

    <section>
      <title>agenda-group</title>

      <para>default value : MAIN</para>

      <para>type : String</para>

      <para>Agenda group's allow the user to partition the Agenda providing
      more execution control. Only rules in the focus group are allowed to
      fire.</para>
    </section>

    <section>
      <title>auto-focus</title>

      <para>default value false</para>

      <para>type : Boolean</para>

      <para>When a rule is activated if the <literal>auto-focus value is true
      and the Rule's </literal> <literal>agenda-group</literal> does not have
      focus then it is given focus, allowing the rule to potentially
      fire.</para>
    </section>

    <section>
      <title>duration</title>

      <para>default value : no default value</para>

      <para>type : long</para>

      <para></para>
    </section>
  </section>

  <section>
    <title>Column</title>

    <figure>
      <title>Column</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="column.svg" format="SVG" role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="column.png" format="PNG" role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Column</title>

      <programlisting>Cheese( )
Cheese( type == "stilton", price &lt; 10 )</programlisting>
    </example>

    <para>A Column is what Drools calls a list of constraints on an Object
    type. The above cases refer to constraints against instances of a Cheese
    object. In the first case, there are obviously no constraints, so this
    Column will match all instances of Cheese that it finds in working memory.
    In the latter case, there are 2 constraints on "fields" that must be met
    before the Cheese object will be matched (they are seperated by a comma,
    which implicitly means "and").</para>

    <figure>
      <title>Column</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="bound_column.svg" format="SVG"
                     role="" />
        </imageobject>

        <imageobject>
          <imagedata align="center" fileref="bound_column.png" format="PNG"
                     role="" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>Bound Column</title>

      <programlisting>cheapStilton : Cheese( type == "stilton", price &lt; 10 )</programlisting>
    </example>

    <para>This is similar to the previous case, but in this case we are
    binding a variable to that instance of Cheese that the rule engine will
    match. This means you can use cheapStilton in another condition, or
    perhaps in the consequence part of the rule. You can also eat it, but I
    wouldn't.</para>

    <section>
      <title>Field Constraints</title>

      <para>Field constraints place constraints on the Fact objects for the
      rule engine to match/select out of working memory. They work
      comparing/evaluating "field" values from the fact object
      instances.</para>

      <para>A "field" is not a field in the sense of a public or private
      member of a class. A field is an accessible method. If your model
      objects follow the java bean pattern, then fields are accessed via
      "getXXX" or "isXXX" methods (these are methods that take no arguments,
      and return something). You can access fields either by using the
      bean-name convention (so "getType" can be accessed as "type") or by
      specifying the whole method name (without any brackets).</para>

      <para>For example, refering to our Cheese class, the following are
      equivalent: Cheese(type == ...), and Cheese(getType == ...). This means
      that you can use model objects that aren't strictly java beans. However,
      make sure that you are accessing methods that take no parameters, and
      are infact "accessors" (as in, they don't change the state of the object
      in a way that may effect the rules - remember that the rule engine
      effectively caches the results of its matching inbetween invocations to
      make it faster).</para>

      <para>Note that if primitive types are used for a field, Drools will
      autobox them to their corresponding object types (even if you are using
      java 1.4). On the whole, it is probably best to use the non primitive
      types in the model objects you are using in your rules. If you use Java
      5, then you get the best of both worlds (you can let the compiler
      autobox for you - much neater).</para>

      <section>
        <title>Operators</title>

        <figure>
          <title>Operators</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="operator.svg" format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="operator.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>There are a number of <indexterm>
            <primary>operatorst</primary>
          </indexterm>opreators that can be used with the various <indexterm>
            <primary>Field Constraint</primary>
          </indexterm>Field Constraints. Valid operators are dependent on the
        field type. Generally they are self explanatory based on the type of
        data: for instance, for date fields, "&lt;" means "before" and so on.
        "Matches" is only applicable to string fields, "contains" and
        "excludes" is only applicable to Collection type fields.</para>
      </section>

      <section>
        <title>Literal Constraints</title>

        <para>The most basic of Field Constraints is the <indexterm>
            <primary>Literal Constraint</primary>
          </indexterm>Literal Constraint which allows the user to constrain a
        field to a given value.</para>

        <para>A note on nulls: you can do checks against fields that are or
        maybe null, using == and != as you would expect, and the literal
        "null" keyword, like: Cheese(type != null).</para>

        <figure>
          <title>Literal Constraints</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="literal_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="literal_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <simplesect>
          <title>Numeric</title>

          <para>All standard java numeric primitives are supported</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>

            <listitem>
              <para>&gt;</para>
            </listitem>

            <listitem>
              <para>&lt;</para>
            </listitem>

            <listitem>
              <para>&gt;=</para>
            </listitem>

            <listitem>
              <para>&lt;=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Numeric Literal Constraint</title>

            <programlisting>Cheese( quantity == 5 )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Date</title>

          <para>Currently only "dd-mmm-yyyy" date format is supported by
          default. You can customise this by providing an alternative date
          format mask as a System property ("drools.dateformat" is the name of
          the property). If more control is required, use the predicate
          constraint.</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>

            <listitem>
              <para>&gt;</para>
            </listitem>

            <listitem>
              <para>&lt;</para>
            </listitem>

            <listitem>
              <para>&gt;=</para>
            </listitem>

            <listitem>
              <para>&lt;=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Date Literal Constraint</title>

            <programlisting>Cheese( bestBefore &lt; "27-Oct-2007" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>String</title>

          <para>Any valid Java String is allowed.</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>==</para>
            </listitem>

            <listitem>
              <para>!=</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>String Literal Constraint</title>

            <programlisting>Cheese( type == "stilton" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Boolean</title>

          <para>only true or false can be used. 0 and 1 are not recognised,
          nor is <literal>Cheese ( smelly )</literal> is not allowed</para>

          <para>Valid operators:</para>

          <itemizedlist>
            <listitem>
              <para>true</para>
            </listitem>

            <listitem>
              <para>false</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Boolean Literal Constraint</title>

            <programlisting>Cheese( smelly == true )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Matches Operator</title>

          <para>Any valid Java <indexterm>
              <primary>regular expression</primary>
            </indexterm>Regular Expression can be used to match String
          fields.</para>

          <example>
            <title>Regular Expression Constraint</title>

            <programlisting>Cheese( type matches "(Buffulo)?\\S*Mozerella" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Contains Operator</title>

          <para><literal>'contains' </literal>is a special operator that can
          be used to check if a field's <indexterm>
              <primary>Collection</primary>
            </indexterm>Collection contains an object.</para>

          <example>
            <title>Literal Cosntraints with Collections</title>

            <programlisting>CheeseCounter( cheeses contains "stilton" )</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Excludes Operator</title>

          <para><literal>'excludes' </literal>is a special operator that can
          be used to check if a field's <indexterm>
              <primary>Collection</primary>
            </indexterm>Collection does not contains an object.</para>

          <example>
            <title>Literal Cosntraints with Collections</title>

            <programlisting>CheeseCounter( cheeses excludes "cheddar" )</programlisting>
          </example>
        </simplesect>
      </section>

      <section>
        <title>Bound Variable Constraint</title>

        <figure>
          <title>Bound Variable Declaration</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="boundvariable_constraints.svg" format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center"
                         fileref="boundvariable_constraints.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Variables can be bound to Facts and and Fields and then used in
        subsequent Field Constraints. A bound variable is called a <indexterm>
            <primary>declaration</primary>
          </indexterm>Declaration. Declarations cannot be used with
        <literal>'matches'</literal>, although it works with
        <literal>'contains'</literal>. Valid operators are determined by the
        type of the field being constrained.</para>

        <example>
          <title>Bound Field using '==' operator</title>

          <programlisting>Person( likes : favouriteCheese )
Cheese( type == likes )</programlisting>
        </example>

        <example>
          <title>Bound Fact using 'contains' operator</title>

          <programlisting>stilton : Cheese( type == "stilton" )
Cheesery( cheeses contains stilton )</programlisting>
        </example>
      </section>

      <section>
        <title>Predicate Constraints</title>

        <figure>
          <title>Predicate expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="predicate_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="predicate_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>A <indexterm>
            <primary>Predicate</primary>
          </indexterm>Predicate constraint can use any valid Java expression
        as long as it evaluated to a primitive boolean. Previously bound
        declarations can be used in the expression. All bound primitive
        declarations are boxed, there is currently no auto-unboxing (if you
        use java 5, this is all automatic).</para>

        <para>This example will find all pairs of male/femal people where the
        male is 2 years older than the female.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( boyAge : age -&gt; ( girlAge == boyAge + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>

      <section>
        <title>Return Value Constraints</title>

        <figure>
          <title>Return Value expression</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="returnvalue_constraints.svg"
                         format="SVG" />
            </imageobject>

            <imageobject>
              <imagedata align="center" fileref="returnvalue_constraints.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>A <indexterm>
            <primary>Return Value</primary>
          </indexterm>Return Value constraint can use any valid Java
        expression as long as it returns an object, it cannot return
        primitives. Previously bound declarations can be used in the
        expression. All bound primitive declarations are boxed, there is
        currently no auto-unboxing. The returned value must be boxed if its a
        primitive (unless you are using Java 5, in which case you don't have
        to worry. If you are stuck on Java 1.4, I can recommend some headache
        tablets).</para>

        <para>Like the Predicate example this will find all pairs of
        male/femal people where the male is 2 years older than the female.
        Notice here we didn't have to bind the boyAge, making it a little
        simpler to read.</para>

        <example>
          <title>Return Value operator</title>

          <programlisting>Person( girlAge : age, sex = "F" )
Person( age == ( girlAge + 2 ), sex = 'M' )
</programlisting>
        </example>
      </section>
    </section>
  </section>

  <section>
    <title>Conditional Elements</title>

    <para>Conditional elements work on one or more Columns (which were
    described above). The most common one is "and" which is implicit when you
    have multiple Columns in the LHS of a rule that are not connected in
    anyway.</para>

    <section>
      <title>'and'</title>

      <figure>
        <title>and</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="and.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="and.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : and, or, not, exists, column</para>

      <example>
        <title>Column</title>

        <programlisting>Cheese( cheeseType : type ) &amp;&amp; Person( favouriteCheese == cheeseType )
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )</programlisting>
      </example>
    </section>

    <section>
      <title>'or'</title>

      <figure>
        <title>or</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="or.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="or.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : and, or, not, exists, column</para>

      <example>
        <title>or</title>

        <programlisting>Person( sex == "f", age &gt; 60 ) || Person( sex == "m", age &gt; 65 )
Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 )
</programlisting>
      </example>

      <figure>
        <title>or</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="or_with_binding.svg"
                       format="SVG" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="or_with_binding.png"
                       format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <example>
        <title>or with binding</title>

        <programlisting>pensioner : Person( sex == "f", age &gt; 60 ) || pensioner : Person( sex == "m", age &gt; 65 ) 
pensioner : ( Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 ) )</programlisting>
      </example>

      <para>Care must be taken when binding with an "or" conditional element,
      as this may yield apparently unpredictable results if both conditions
      match (its not XOR). Also, you may accidentally refer to a variable that
      is bound to a column that does not exist in a given activation (giving
      null pointer exceptions, and the associated headaches).</para>
    </section>

    <section>
      <title>'eval'</title>

      <figure>
        <title>eval</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="eval.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="eval.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children : none</para>

      <para>Eval is essentially a catch all which allows any semantic code
      (that returns a boolean) to be executed. This can refer to variables
      that were bound in the LHS of the rule, and functions in the rule
      package. An eval should be the last conditional element in the LHS of a
      rule.</para>

      <para>Evals cannot be indexed and thus are not as optimal as using Field
      Constraints. However this makes them ideal for being used when functions
      return values that change over time, which is not allowed within Field
      Constraints.</para>

      <para>For folks who are familiar with Drools 2.x lineage, the old Drools
      paramater and condition tags are equivalent to:</para>

      <para>p1 : Parameter() p2 : Parameter()</para>

      <para>eval( /* your condition here, involving the parameters */)</para>

      <example>
        <title>or</title>

        <programlisting></programlisting>
      </example>
    </section>

    <section>
      <title>'not'</title>

      <figure>
        <title>not</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="not.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="not.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children: Column</para>

      <para>Future versions of Drools will allow 'and' and 'or' to be nested
      in 'not'</para>

      <example>
        <title>No Busses</title>

        <programlisting>not Bus()</programlisting>
      </example>

      <example>
        <title>No red Busses</title>

        <programlisting>not Bus(color == "red")</programlisting>
      </example>
    </section>

    <section>
      <title>'exists'</title>

      <figure>
        <title>exists</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="exists.svg" format="SVG" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="exists.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>valid children: Column</para>

      <para>Future versions of Drools will allow 'and' and 'or' to be nested
      in 'not'.</para>

      <para>Think of exist as meaning "at least one..". It is different from
      just having the Column on its own. If you had the column on its on, its
      kind of like saying "for each one of...". if you use exist with a
      Column, then the rule will only activate once regardless of how much
      data there is in working memory that matches that condition.</para>

      <example>
        <title>Atleast one Bus</title>

        <programlisting>exists Bus()</programlisting>
      </example>

      <example>
        <title>Atleast one red Bus</title>

        <programlisting>exists Bus(color == "red")</programlisting>
      </example>
    </section>

    <section>
      <title>'group'</title>

      <figure>
        <title>group</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="group.svg" format="SVG" role="" />
          </imageobject>

          <imageobject>
            <imagedata align="center" fileref="group.png" format="PNG" role="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Grouping is similar to using parentheses in algebra, it makes the
      order of operations explicit.</para>
    </section>
  </section>
</section>