<?xml version="1.0" encoding="UTF-8"?>
<section>
  <title>Advanced Conditional Elements</title>

  <note>
    <para><replaceable>(updated to Drools 4.0)</replaceable></para>
  </note>

  <para>Drools 4.0 introduces a whole new set of conditional elements in order
  to support full First Order Logic expressiveness, as well as some facilities
  for handling collections of facts. This section will detail the following
  new Conditional Elements:</para>

  <itemizedlist>
    <listitem>
      <para>from </para>
    </listitem>

    <listitem>
      <para>collect</para>
    </listitem>

    <listitem>
      <para>accumulate </para>
    </listitem>

    <listitem>
      <para>forall</para>
    </listitem>
  </itemizedlist>

  <section>
    <title>From</title>

    <para>The <emphasis role="bold">from</emphasis> Conditional Element allows
    users to specify a source for patterns to reason over. This allows the
    engine to reason over data not in the Working Memory. This could be a
    sub-field on a bound variable or the results of a method call. It is a
    powerful construction that allows out of the box integration with other
    application components and frameworks. One common example is the
    integration with data retrieved on-demand from databases using hibernate
    named queries.</para>

    <para>The expression used to define the object source is any expression
    that follows regular MVEL syntax. I.e., it allows you to easily use object
    property navigation, execute method calls and access maps and collections
    elements.</para>

    <para>Here is a simple example of reasoning and binding on another pattern
    sub-field: </para>

    <para><programlisting>rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    # zip code is ok
end
</programlisting></para>

    <para>With all the flexibility from the new expressiveness in the Drools
    engine you can slice and dice this problem many ways. This is the same but
    shows how you can use a graph notation with the 'from': </para>

    <para><programlisting>rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    # zip code is ok
end
</programlisting></para>

    <para>Previous examples were reasoning over a single pattern. The
    <emphasis role="bold">from</emphasis> CE also support object sources that
    return a collection of objects. In that case, <emphasis
    role="bold">from</emphasis> will iterate over all objects in the
    collection and try to match each of them individually. For instance, if we
    want a rule that applies 10% discount to each item in an order, we could
    do:</para>

    <programlisting>rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
then
    # apply discount to $item
end
</programlisting>

    <para>The above example will cause the rule to fire once for each item
    whose value is greater than 100 for each given order.</para>

    <para>The next example shows how we can reason over the results of a
    hibernate query. The Restaurant pattern will reason over and bind with
    each result in turn: </para>
  </section>

  <section>
    <title>Collect</title>

    <para>The <emphasis role="bold">collect</emphasis> Conditional Element
    allows rules to reason over collection of objects collected from the given
    source or from the working memory. A simple example:</para>

    <programlisting>import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    # Raise priority, because system $system has
    # 3 or more alarms pending. The pending alarms
    # are $alarms.
end
</programlisting>

    <para>In the above example, the rule will look for all pending alarms in
    the working memory for each given system and group them in ArrayLists. If
    3 or more alarms are found for a given system, the rule will fire.</para>

    <para>The <emphasis role="bold">collect</emphasis> CE result pattern can
    be any concrete class that implements tha java.util.Collection interface
    and provides a default no-arg public constructor. I.e., you can use
    default java collections like ArrayList, LinkedList, HashSet, etc, or your
    own class, as long as it implements the java.util.Collection interface and
    provide a default no-arg public constructor.</para>

    <para>Both source and result patterns can be constrained as any other
    pattern.</para>

    <para>Variables bound before the <emphasis role="bold">collect</emphasis>
    CE are in the scope of both source and result patterns and as so, you can
    use them to constrain both your source and result patterns. Although, the
    <emphasis>collect( ... )</emphasis> is a scope delimiter for bindings,
    meaning that any binding made inside of it, is not available for use
    outside of it.</para>

    <para>Collect accepts nested <emphasis role="bold">from</emphasis>
    elements, so the following example is a valid use of <emphasis
    role="bold">collect</emphasis>:</para>

    <programlisting>import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children &gt; 0 ) 
                             from $town.getPeople() 
                           )
then
    # send a message to all mothers
end
</programlisting>
  </section>

  <section>
    <title>Accumulate</title>

    <para>The <emphasis role="bold">accumulate</emphasis> Conditional Element
    is a more flexible and powerful form of <emphasis
    role="bold">collect</emphasis> Conditional Element, in the sense that it
    can be used to do what <emphasis role="bold">collect</emphasis> CE does
    and also do things that <emphasis role="bold">collect</emphasis> CE is not
    capable to do. Basically what it does is it allows a rule to iterate over
    a collection of objects, executing custom actions for each of the
    elements, and at the end return a result object.</para>

    <para>The general syntax of the <emphasis
    role="bold">accumulate</emphasis> CE is:</para>

    <programlisting><replaceable>&lt;result pattern&gt;</replaceable> from accumulate( <replaceable>&lt;source pattern&gt;</replaceable>,
                                  init( <replaceable>&lt;init code&gt;</replaceable> ),
                                  action( <replaceable>&lt;action code&gt;</replaceable> ),
                                  reverse( <replaceable>&lt;reverse code&gt;</replaceable> ),
                                  result( <replaceable>&lt;result expression&gt;</replaceable> ) )
</programlisting>

    <para>The meaning of each of the elements is the following:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">&lt;source pattern&gt;</emphasis>: the
        source pattern is a regular pattern that the engine will try to match
        against each of the source objects.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">&lt;init code&gt;</emphasis>: this is a
        semantic block of code in the selected dialect that will be executed
        once for each tuple, before iterating over the source objects.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">&lt;action code&gt;</emphasis>: this is a
        semantic block of code in the selected dialect that will be executed
        for each of the source objects.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">&lt;reverse code&gt;</emphasis>: this is
        an optional semantic block of code in the selected dialect that if
        present will be executed for each source object that no longer matches
        the source pattern. The objective of this code block is to "undo" any
        calculation done in the &lt;action code&gt; block, so that the engine
        can do decremental calculation when a source object is modified or
        retracted, hugely improving performance of these operations.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">&lt;result expression&gt;</emphasis>: this
        is a semantic expression in the selected dialect that is executed
        after all source objects are iterated.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">&lt;result pattern&gt;</emphasis>: this is
        a regular pattern that the engine tries to match against the object
        returned from the &lt;result expression&gt;. If it matches, the
        <emphasis role="bold">accumulate</emphasis> conditional element
        evaluates to <emphasis role="bold">true</emphasis> and the engine
        proceeds with the evaluation of the next CE in the rule. If it does
        not matches, the <emphasis role="bold">accumulate</emphasis> CE
        evaluates to <emphasis role="bold">false</emphasis> and the engine
        stops evaluating CEs for that rule.</para>
      </listitem>
    </itemizedlist>

    <para>It is easier to understand if we look at an example:</para>

    <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end
</programlisting>

    <para>In the above example, for each Order() in the working memory, the
    engine will execute the <emphasis role="bold">init code</emphasis>
    initializing the total variable to zero. Then it will iterate over all
    OrderItem() objects for that order, executing the <emphasis
    role="bold">action</emphasis> for each one (in the example, it will sum
    the value of all items into the total variable). After iterating over all
    OrderItem, it will return the value corresponding to the <emphasis
    role="bold">result expression</emphasis> (in the above example, the value
    of the total variable). Finally, the engine will try to match the result
    with the Number() pattern and if the double value is greater than 100, the
    rule will fire.</para>

    <para>The example used java as the semantic dialect, and as such, note
    that the usage of ';' is mandatory in the init, action and reverse code
    blocks. The result is an expression and as such, it does not admit ';'. If
    the user uses any other dialect, he must comply to that dialect specific
    syntax.</para>

    <para>As mentioned before, the <emphasis role="bold">reverse
    code</emphasis> is optional, but it is strongly recommended that the user
    writes it in order to benefit from the <emphasis>improved performance on
    update and retracts</emphasis>.</para>

    <para>The <emphasis role="bold">accumulate</emphasis> CE can be used to
    execute any action on source objects. The following example instantiates
    and populates a custom object:</para>

    <programlisting>rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount &gt; 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end</programlisting>

    <section>
      <title>Accumulate Functions</title>

      <para>The accumulate CE is a very powerful CE, but it gets real
      declarative and easy to use when we use predefined functions that are
      known as Accumulate Functions. They work exactly like accumulate, but
      instead of explicitly writing custom code in every accumulate CE, the
      user can use predefined code for common operations. </para>

      <para>For instance, the rule to apply discount on orders written in the
      previous section, could be written in the following way, using
      Accumulate Functions:</para>

      <programlisting>rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue &gt; 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end
</programlisting>

      <para>In the above example, sum is an AccumulateFunction and will sum
      the $value of all OrderItems and return the result.</para>
    </section>
  </section>
</section>