<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
  <title>Miss Manners</title>

  <section>
    <title>Introduction</title>

    <para>Miss Manners is throwing a party and being the good host she wants
    to arrange good seating. Her initial design arranges everyone in male
    female pairs, but then she worries about people have things to talk about;
    what is a good host to do? So she decides to note the hobby of each guest
    so she can then arrange guests in not only male and female pairs but also
    ensure that a guest has someone to talk about a common hobby, from either
    their left or right side.</para>

    <figure>
      <title>Miss Manners' Guests</title>

      <mediaobject>
        <imageobject>
          <imagedata contentwidth="400" depth="100%"
                     fileref="guests_at_table.svg" format="SVG" scalefit="1"
                     width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>BenchMarking</title>

      <para>5 benchmarks were established in the 1991 paper "Effects of
      Database Size on Rule System Performance: Five Case Studies" by Brant,
      Timothy Grose, Bernie Lofaso, &amp; Daniel P. Miranker.</para>

      <itemizedlist>
        <listitem>
          <para>Manners</para>

          <itemizedlist>
            <listitem>
              <para>Uses a depth-first search approach to determine the
              seating arrangements of boy/girl and one common hobby for dinner
              guests</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Waltz</para>

          <itemizedlist>
            <listitem>
              <para>line labelling for simple scenes by constraint
              propagation</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>WaltzDB</para>

          <itemizedlist>
            <listitem>
              <para>More general version of Walts to be able to adapt to a
              database of facts</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>ARP</para>

          <itemizedlist>
            <listitem>
              <para>Route planner for a robotic air vehicle using the A*
              search algorithm</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Weavera</para>

          <itemizedlist>
            <listitem>
              <para>VLSI router for channels and boxes using a black-board
              technique</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Manners has become the de facto rule engine benchmark with waltz
      often still used. These 5 benchmarks are also published at the
      University of Texas <ulink
      url="http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/">http://www.cs.utexas.edu/ftp/pub/ops5-benchmark-suite/</ulink>.</para>
    </section>

    <section>
      <title>Miss Manners Execution Flow</title>

      <para>Afer the first Seating arrangement has been assigned a depth-first
      recursion occurs which repeatedly assigns correct Seating arrangements
      until the last seat is assigned. Manners uses a Context instance to
      control execution flow; the activity diagram is partitioned to show the
      relation of the rule execution to the current Context state.</para>

      <figure>
        <title>Manners Activity Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata contentwidth="400"
                       fileref="manners_activity_diagram.svg" format="SVG"
                       scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>The Data and Results</title>

      <para>Before going deeper into the rules lets first take a look at the
      asserted data and the resulting Seating arrangement. The data is a
      simple set of 5 guests who should be arranged in male/female pairs with
      common hobbies.</para>

      <para><emphasis role="bold">The Data</emphasis> (guest (name n1) (sex m)
      (hobby h1)) (guest (name n2) (sex f) (hobby h1)) (guest (name n2) (sex
      f) (hobby h3)) (guest (name n3) (sex m) (hobby h3)) (guest (name n4)
      (sex m) (hobby h1)) (guest (name n4) (sex f) (hobby h2)) (guest (name
      n4) (sex f) (hobby h3)) (guest (name n5) (sex f) (hobby h2)) (guest
      (name n5) (sex f) (hobby h1))</para>

      <para>Each line of the results list is printed per execution of the
      “Assign Seat” rule. They key bit to notice is that each line has pid one
      greater than the last, the significance of this will be explained in t
      he “Assign Seating” rule description. The 'l' and the 'r' refer to the
      left and right, 's' is sean and 'n' is the guest name. In my actual
      implementation I used longer notation, 'leftGuestName', but this is not
      practicle in a printed article. I found the notation of left and right
      preferable to the original OPS5 '1' and '2'.</para>

      <para><emphasis role="bold">The Results</emphasis> [Seating id=1, pid=0,
      done=true, ls=1, ln=n5, rs=1, rn=n5] [Seating id=2, pid=1, done=false,
      ls=1, ln=n5, rs=2, rn=n4] [Seating id=3, pid=2, done=false, ls=2, ln=n4,
      rs=3, rn=n3] [Seating id=4, pid=3, done=false, ls=3, rn=n3, rs=4, rn=n2]
      [Seating id=5, pid=4, done=false, ls=4, ln=n2, rs=5, rn=n1]</para>
    </section>
  </section>

  <section>
    <title>Indepth look</title>

    <para></para>

    <section>
      <title>Conflict Resolution</title>

      <para>As the introduction states, manners is a depth-first or LIFO
      example. Depth-first refers to the Conflict Resolution strategy used to
      solve the problem. OPS5 had two strategies, LEX and MEA, LEX is a chain
      of several stratagies including Salience, Recency, Complexity:</para>

      <blockquote>
        <attribution>Clips Reference Manual</attribution>

        <para>Every fact and instance is marked internally with a “time tag”
        toindicate its relative recency with respect to every other fact and
        instance in the system. The pattern entities associated with each rule
        activation are sorted in descending order for determining placement.
        An activation with a more recent pattern entities is placed before
        activations with less recent pattern entities. To determine the
        placement order of two activations, compare the sorted time tags of
        the two activations one by one starting with the largest time tags.
        The comparison should continue until one activation’s time tag is
        greater than the other activation’s corresponding time tag. The
        activation with the greater time tag is placed before the other
        activation on the agenda. If one activation has more pattern entities
        than the other activation and the compared time tags are all
        identical, then the activation with more time tags is placed before
        the other activation on the agenda.</para>
      </blockquote>

      <para>Clips is able to specify the LEX and MEA strategies as well as
      others, however the default is a Depth strategy which is implemented
      from the LEX Recency strategy:</para>

      <blockquote>
        <attribution>Clips Reference Manual</attribution>

        <para>Newly activated rules are placed above all rules of the same
        salience. For example, given that fact-a activates rule-1 and rule-2
        and fact-b activates rule-3 and rule-4, then if fact-a is asserted
        before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on
        the agenda. However, the position of rule-1 relative to rule-2 and
        rule-3 relative to rule-4 will be arbitrary.</para>
      </blockquote>

      <para>Jess only has two strategies, Depth and Breadth, which are
      documented the same as the Clips ones. When I first implemented Miss
      Manners in Drools 3.0 using our Depth strategy was not producing the
      correct results, which I initially found very worrying; what comes next
      is a detailed look at the main rules in Manners XXXXXXX</para>
    </section>

    <section>
      <title>Assign First Seat</title>

      <para>Once the context is changed to START_UP Activations are created
      for all asserted Guests; because all Activations are created as the
      result of a single Working Memory action, they all have the same
      Activation time tag. Using the Depth, or Breadth, Conflict Resolution
      strategy the Activations would be fired arbitrary. With LEX's Recency
      the last asserted Guest would have a higher time tag and its Activation
      would fire. The execution order in this rule has little importance, but
      has a big impact in the rule "Assign Seat". The Activation fires and
      asserts the first Seating arrangement, a Path and then sets the
      Context's state to create Activatiosn for "Assign Seat".</para>

      <programlisting>rule assignFirstSeat() {
  Context context;
  Guest guest;
  Count count;
  when {
    context : Context( state == Context.START_UP )
    guest : Guest()
    count : Count()
  } then {
    String guestName = guest.getName();
    drools.assert( new Seating( count.getValue(), 1, true, 1, guestName, 1, guestName) );
    drools.assert( new Path( count.getValue(), 1, guestName ) );
    count.setCount(  count.getValue() + 1 );
    context.setPath( Context.ASSIGN_SEATS );
  }
} 
</programlisting>
    </section>

    <section>
      <title>Assign Seat</title>

      <para>This rule determines each of the Seating arrangements. The Rule
      creates cross product solutions for ALL asserted Seating arrangements
      against ALL the asserted guests; accept against itself or any already
      assigned Chosen solutions.</para>

      <programlisting>rule assignSeat() {  
  Context context;
  int seatingId, seatingPid;
  String seatingRightGuestName, leftGuestName;
  Sex rightGuestSex;
  Hobby rightGuestHobby;
  Count count; 

  when {
    context : Context( state == Context.ASSIGN_SEATS )
    Seating( seatingId:id, seatingPid:pid, pathDone == true 
    seatingRightSeat:rightSeat seatingRightGuestName:rightGuestName )
    Guest( name == seatingRightGuestName, rightGuestSex:sex, rightGuestHobby:hobby )
    Guest( leftGuestName:name , sex != rightGuestSex, hobby == rightGuestHobby )
    count : Count()
    not ( Path( id == seatingId, guestName == leftGuestName) )
    not ( Chosen( id == seatingId, guestName == leftGuestName, hobby == rightGuestHobby) )
  } then {
    int newSeat = rightSeat + 1;
    drools.assert( new Seating( countValue, id, false, coung.getValue(), rightSeat, rightSeatName, newSeat, leftGuestName);
    drools.assert( new Path( countValue, leftGuestName, newSeat );
    drools.assert( new Chosen( id, leftGuestName, rightGuestHobby ) );
    count.setCount(  countValue + 1 );
    context.setPath( Context.MAKE_PATH );
  }
} 
</programlisting>

      <para>However, as can be seen from the printed results shown earlier, it
      is essential that only the Seating with the highest pid cross product be
      chosen – yet how can this be possible if we have Activations for nearly
      all existing Seating and Guests. For example on the third iteration of
      "Assing Seat" these are the produced Activations, remember this is from
      a very small data set and with larger data sets there would be many more
      possible Activated Seating solutions, with multiple solutions per
      pid:</para>

      <para>=&gt;[ActivationCreated(35): rule=findSeating [fid:19:33]:[Seating
      id=3, pid=2, done=true, ls=2, ln=n4, rs=3, rn=n3] [fid:4:4]:[Guest
      name=n3, sex=m, hobbies=h3] [fid:3:3]:[Guest name=n2, sex=f,
      hobbies=h3], [fid:12:29] =&gt;[ActivationCreated(35): rule=findSeating
      [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4]
      [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest name=n2,
      sex=f, hobbies=h1] =&gt;[ActivationCreated(35): rule=findSeating
      [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5]
      [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1,
      sex=m, hobbies=h1] Notice that each Activation has the same time tag of
      35, as they were all activated by the change in Context to ASSIGN_SEATS.
      With OPS5 and LEX it would correctly fire the Activation with the last
      asserted Seating. With Depth strategy the execution is arbitrary yet
      Manners does correctly execute for Jess and Clips using the Depth
      strategy. Clips support, via the public fourms, have said that Manners
      was</para>

      <blockquote>
        <attribution>Clips Support Forum</attribution>

        <para>The default conflict resolution strategy for CLIPS, depth, is
        different than the default conflict resolution strategy used by OPS5.
        Therefore if you directly translate an OPS5 program to CLIPS, but use
        the default depth conflict resolution strategy, you're only likely to
        get the correct behavior by coincidence. The lex and mea conflict
        resolution strategies are provided in CLIPS to allow you to quickly
        convert and correctly run an OPS5 program in CLIPS</para>
      </blockquote>

      <para>Early Drools 3.0 implementations, implementing Depth, would not
      work as all the Activations had the same priority and the reliance on
      arbitrary execution meant that Seatings with lower pids where firing. A
      LEX style recency strategy was implemented and the benchmark worked
      correctly. This leaves the question how does Jess and Clips work. While
      I haven’t looked at Jess or Clips code Peter Lin has confirmed that
      Clips uses LinkedLists for the memory. This suggests the joins remember
      and attempt joins based on the fact assertion order into the node; thus
      Activation firing would follow fact assertion order. An interesting
      observation in Clips is that Manners fails if the strategy is set to
      Breadth, showing that the order the Activations with the same time tag
      are placed on the Agenda are still executed in LIFO/FIFO order.</para>
    </section>

    <section>
      <title>Make Path and Path Done</title>

      <para>Make Path always fires before Path Done. A Path is asserted for
      each Seating arrangement up to the last asserted Seating. Notice that
      Path Done is a subset of Make Path, so how do we ensure that Make Path
      fires first?</para>

      <programlisting>rule makePath() {
  Context context;
  int seatingId, seatingPid, pathSeat;
  String pathGuestName;
  
  when {
    context : Context( state == Context.MAKE_PATH )
    Seating( seatingId:id, seatingPid:pid, pathDone == false )
    Path( id == seatingPid, pathGuestName:guest, pathSeat:seat )
    (not Path( id == seatingId, guestName == pathGuestName )
  } else {
    drools.assert( new Path( seatingId, pathSeat, pathGuestName ) );  
  }
}
</programlisting>

      <programlisting>rule pathDone() { 
  Context context; Seating seating; 
  when { 
    context : Context( state == Context.MAKE_PATH ) 
    seating : Seating( pathDone == false ) 
  } then { 
    seating.setPathDone( true ); 
    context.setName( Context.CHECK_DONE ); 
  } 
}
</programlisting>

      <figure>
        <title>Rete Diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata contentdepth="500" contentwidth="" depth=""
                       fileref="make_path.svg" format="SVG" role=""
                       scalefit="1" width="" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>With OPS5 LEX the recency strategy says that if all compared facts
      have the same time tag then the activation with more facts wins; which
      would make sure that "Make Path" always fires before "Path Done". With
      Clips i believe its because the propagation reaches the "Path Done"
      Terminal node first and creates its Activation first; thus with LIFO the
      first created Activation will fire last.</para>
    </section>

    <section>
      <title>Continue and Are We Done</title>

      <para>"Are We Done" only activates when the last seat is assigned, at
      which point both rules will be activated. For the same reason that "Make
      Path" always wins over "Path Done" "Are We Done" will take priority over
      "Continue".</para>

      <programlisting> rule areWeDone() { 
  Context context; LastSeat lastSeat; 
  when { 
    context : Context( state == Context.CHECK_DONE ) 
    LastSeat( lastSeat: seat )
    Seating( rightSeat == lastSeat ) 
  } then { 
    context.setState(Context.PRINT_RESULTS ); 
  } 
}
</programlisting>

      <programlisting>rule continue() { 
  Context context; 
  when { 
    context : Context( state == Context.CHECK_DONE ) 
  } then { 
    context.setState( Context.ASSIGN_SEATS ); 
  } 
}
</programlisting>
    </section>
  </section>

  <section>
    <title>Conclusion</title>

    <para>What have we learned from this? Firstly that Manners was designed to
    run with OPS5 Recency and that if works under Depth then from a user point
    of view it should be considered purely coincidence. This shows that a new
    benchmark is needed for engines that run with Depth Conflict
    Resolution.</para>
  </section>

  <section>
    <title>Output Summary</title>

    <para><emphasis role="bold">Assign First seat</emphasis>
    =&gt;[fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1,
    rn=n5] =&gt;[fid:14:14]:[Path id=1, seat=1, guest=n5] Straight way we have
    two activations, with the same activation number and thus will be executed
    arbitrary. In this instance both have id=1 and pid=0, so it doesn’t matter
    which one fires. The * indicates the activation that does fire.
    ==&gt;[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1,
    pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5,
    sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]
    ==&gt;[ActivationCreated(16): rule=findSeating [fid:13:13]:[Seating id=1 ,
    pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5,
    sex=f, hobbies=h1] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1]* Notice
    the increase in pid and that we have added a new Path. For each Seating id
    we add Path objects for each Seat up to the current Seat. This means each
    iteration will add one more Path object than the previous instance. It is
    the Path and Chosen objects that make sure we don’t try to activate a
    Seating guest against themselves. <emphasis role="bold">Assign
    Seating</emphasis> =&gt;[fid:15:17] :[Seating id=2 , pid=1 , done=false,
    ls=1, lg=n5, rs=2, rn=n4] =&gt;[fid:16:18]:[Path id=2, seat=2, guest=n4]
    =&gt;[fid:17:19]:[Chosen id=1, name=n4, hobbies=h1]
    =&gt;[ActivationCreated(21): rule=makePath [fid:15:17] : [Seating id=2,
    pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4] [fid:14:14] : [Path id=1,
    seat=1, guest=n5]* ==&gt;[ActivationCreated(21): rule=pathDone [Seating
    id=2, pid=1, done=false, ls=1, ln=n5, rs=2, rn=n4]* <emphasis
    role="bold">Make Path</emphasis> =&gt;[fid:18:22:[Path id=2, seat=1,
    guest=n5]] <emphasis role="bold">Path Done</emphasis> <emphasis
    role="bold">Continue Process</emphasis> =&gt;[ActivationCreated(25):
    rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5,
    rs=2, rn=n4] [fid:7:7]:[Guest name=n4, sex=f, hobbies=h3] [fid:4:4] :
    [Guest name=n3, sex=m, hobbies=h3]* =&gt;[ActivationCreated(25):
    rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5,
    rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest
    name=n2, sex=f, hobbies=h1], [fid:12:20] : [Count value=3], ]
    =&gt;[ActivationCreated(25): rule=findSeating [fid:13:13]:[Seating id=1,
    pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5,
    sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] <emphasis
    role="bold">Assign Seating</emphasis> =&gt;[fid:19:26]:[Seating id=3,
    pid=2, done=false, ls=2, lnn4, rs=3, rn=n3]] =&gt;[fid:20:27]:[Path id=3,
    seat=3, guest=n3]] =&gt;[fid:21:28]:[Chosen id=2, name=n3, hobbies=h3}]
    =&gt;[ActivationCreated(30): rule=makePath [fid:19:26]:[Seating id=3,
    pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3] [fid:18:22]:[Path id=2,
    seat=1, guest=n5]* =&gt;[ActivationCreated(30): rule=makePath
    [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3, rn=n3]
    [fid:16:18]:[Path id=2, seat=2, guest=n4]* =&gt;[ActivationCreated(30):
    rule=done [fid:19:26]:[Seating id=3, pid=2, done=false, ls=2, ln=n4, rs=3,
    rn=n3]* <emphasis role="bold">Make Path</emphasis> =&gt;[fid:22:31]:[Path
    id=3, seat=1, guest=n5] <emphasis role="bold"> Make Path </emphasis>
    =&gt;[fid:23:32] [Path id=3, seat=2, guest=n4] <emphasis role="bold">Path
    Done</emphasis> Continue Processing =&gt;[ActivationCreated(35):
    rule=findSeating [fid:19:33]:[Seating id=3, pid=2, done=true, ls=2, ln=n4,
    rs=3, rn=n3] [fid:4:4]:[Guest name=n3, sex=m, hobbies=h3] [fid:3:3]:[Guest
    name=n2, sex=f, hobbies=h3], [fid:12:29]* =&gt;[ActivationCreated(35):
    rule=findSeating [fid:15:23]:[Seating id=2, pid=1, done=true, ls=1, ln=n5,
    rs=2, rn=n4] [fid:5:5]:[Guest name=n4, sex=m, hobbies=h1] [fid:2:2]:[Guest
    name=n2, sex=f, hobbies=h1] =&gt;[ActivationCreated(35): rule=findSeating
    [fid:13:13]:[Seating id=1, pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5]
    [fid:9:9]:[Guest name=n5, sex=f, hobbies=h1], [fid:1:1] : [Guest name=n1,
    sex=m, hobbies=h1], [fid:12:29] : [Count value=4] <emphasis role="bold">
    Assign Seating</emphasis> =&gt;[fid:24:36]:[Seating id=4, pid=3,
    done=false, ls=3, ln=n3, rs=4, rn=n2]] =&gt;[fid:25:37]:[Path id=4,
    seat=4, guest=n2]] =&gt;[fid:26:38]:[Chosen id=3, name=n2, hobbies=h3]
    ==&gt;[ActivationCreated(40): rule=makePath [fid:24:36]:[Seating id=4,
    pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2] [fid:23:32]:[Path id=3,
    seat=2, guest=n4]* ==&gt;[ActivationCreated(40): rule=makePath
    [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3, rs=4, rn=n2]
    [fid:20:27]:[Path id=3, seat=3, guest=n3]* =&gt;[ActivationCreated(40):
    rule=makePath [fid:24:36]:[Seating id=4, pid=3, done=false, ls=3, ln=n3,
    rs=4, rn=n2] [fid:22:31]:[Path id=3, seat=1, guest=n5]*
    =&gt;[ActivationCreated(40): rule=done [fid:24:36]:[Seating id=4, pid=3,
    done=false, ls=3, ln=n3, rs=4, rn=n2]* <emphasis role="bold">Make Path
    </emphasis> =&gt;fid:27:41:[Path id=4, seat=2, guest=n4] <emphasis
    role="bold">Make Path</emphasis> =&gt;fid:28:42]:[Path id=4, seat=1,
    guest=n5]] <emphasis role="bold">Make Path</emphasis>
    =&gt;fid:29:43]:[Path id=4, seat=3, guest=n3]] <emphasis role="bold"> Path
    Done</emphasis> <emphasis role="bold">Continue Processing</emphasis>
    =&gt;[ActivationCreated(46): rule=findSeating [fid:15:23]:[Seating id=2,
    pid=1, done=true, ls=1, ln=n5, rs=2, rn=n4] [fid:5:5]:[Guest name=n4,
    sex=m, hobbies=h1], [fid:2:2] [Guest name=n2, sex=f, hobbies=h1]
    =&gt;[ActivationCreated(46): rule=findSeating [fid:24:44]:[Seating id=4,
    pid=3, done=true, ls=3, ln=n3, rs=4, rn=n2] [fid:2:2]:[Guest name=n2,
    sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1]*
    =&gt;[ActivationCreated(46): rule=findSeating [fid:13:13]:[Seating id=1,
    pid=0, done=true, ls=1, ln=n5, rs=1, rn=n5] [fid:9:9]:[Guest name=n5,
    sex=f, hobbies=h1] [fid:1:1]:[Guest name=n1, sex=m, hobbies=h1] <emphasis
    role="bold"> Assign Seating</emphasis> =&gt;[fid:30:47]:[Seating id=5,
    pid=4, done=false, ls=4, ln=n2, rs=5, rn=n1] =&gt;[fid:31:48]:[Path id=5,
    seat=5, guest=n1] =&gt;[fid:32:49]:[Chosen id=4, name=n1,
    hobbies=h1]</para>
  </section>
</article>