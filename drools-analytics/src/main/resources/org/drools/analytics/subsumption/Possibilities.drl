#created on: 8.1.2008
package org.drools.analytics.subsumption.patterns

import org.drools.analytics.components.Restriction;
import org.drools.analytics.components.Pattern;
import org.drools.analytics.components.PatternPossibility;
import org.drools.analytics.components.RulePossibility;
import org.drools.analytics.report.components.Redundancy;
import org.drools.analytics.report.components.Subsumption;
import org.drools.analytics.report.components.CauseType;
import org.drools.analytics.report.components.RedundancyType;


#declare any global variables here

rule "Find subsumptant pattern possibilities"
	when
		
		$redundancy :Redundancy(
			left.causeType == CauseType.PATTERN
		)

		# Find two PatternPossibilities.
		$pp1 :PatternPossibility(
			eval( patternId == $redundancy.getLeft().getId() )
		)
		$pp2 :PatternPossibility(
			eval( patternId == $redundancy.getRight().getId() )
		)		
		
		# For every restriction in $pp1 there is a redundancy to restriction in $pp2.
		forall(
			$r :Restriction(
				this memberOf $pp1.items
			)

			Subsumption(
				left == $r,
				right memberOf $pp2.items
			)
		)
		
		# There is no restriction on $pp2 that has no redundancy in $pp1 
		# and has a lower order number than an existing redundancy from $pp2 to $pp1.
		not(
				$r1 :Restriction(
					this memberOf $pp2.items
				)
			and
				$r2 :Restriction(
					this memberOf $pp2.items,
					orderNumber > $r1.orderNumber
				)
			and
				not Subsumption(
					left memberOf $pp1.items,
					right == $r1
				)
			and
				Subsumption(
					left memberOf $pp1.items,
					right == $r2
				)
		)

	then
		insert( new Subsumption( $pp1, $pp2 ) );
end


#
# Finds subsumptant rule possibilities
#
# Depandencies: TODO: Dependencies 
#
rule "Find subsumptant rule possibilities"
	when
		
		$redundancy :Redundancy(
			left.causeType == CauseType.RULE
		)

		# Find two RulePossibilities.
		$rp1 :RulePossibility(
			eval( ruleId == $redundancy.getLeft().getId() )
		)
		$rp2 :RulePossibility(
			eval( ruleId == $redundancy.getRight().getId() )
		)
		
		# For every PatternPossibility in $rp1 there is a redundancy to PatternPossibility in $rp2.
		forall(
			$pp :PatternPossibility(
				this memberOf $rp1.items
			)

			Subsumption(
				left == $pp,
				right memberOf $rp2.items
			)
		)
		
		# There is no PatternPossibility on $rp2 that has no redundancy in $rp1 
		# and has a lower order number than an existing PatternPossibility from $rp2 to $rp1.
		not(
				$pp1 :PatternPossibility(
					this memberOf $rp2.items
				)
			and
				$pp2 :PatternPossibility(
					this memberOf $rp2.items,
					orderNumber > $pp1.orderNumber
				)
			and
				not Subsumption(
					left memberOf $rp1.items,
					right == $pp1
				)
			and
				Subsumption(
					left memberOf $rp1.items,
					right == $pp2
				)
		)
	then
		insert( new Subsumption( $rp1, $rp2 ) );
end

rule "XXX: test rule"
	when
		$redundancy :Redundancy(
			left.causeType == CauseType.RULE
		)

		# Find two RulePossibilities.
		$rp1 :RulePossibility(
			eval( ruleId == $redundancy.getLeft().getId() )
		)
		$rp2 :RulePossibility(
			eval( ruleId == $redundancy.getRight().getId() )
		)
		
		forall(
			$pp :PatternPossibility(
				this memberOf $rp1.items
			)

			Redundancy(
				left == $pp,
				right memberOf $rp2.items
			)
		)
	then
		System.out.println( "pim" );
end

