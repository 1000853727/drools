#created on: 7.9.2007
package org.drools.analytics.redundancy.possibilities

import org.drools.analytics.components.*;
import org.drools.analytics.report.components.Redundancy;
import org.drools.analytics.report.components.Redundancy.RedundancyType;
import org.drools.analytics.report.components.PartialRedundancy;
import org.drools.analytics.report.components.Subsumption;
import org.drools.analytics.report.components.Cause;
import org.drools.analytics.report.components.Cause.CauseType;

import java.util.ArrayList;

#
# Fires when two PatternPossibilities are redundant.
# Marks these possibilities as redundant.
# 
# Example 1: Pattern1( a == b) and Pattern1( a == b)
# Example 2: Pattern1( a == b || a == c) and Pattern1( a == b)
rule "Find pattern possibility redundancy"
	when
		$ppr :Redundancy( 
			type == Redundancy.RedundancyType.WEAK,
			left.causeType == Cause.CauseType.PATTERN 
		)

		# Find two PatternPossibilities.
		$pp1 :PatternPossibility(
			eval( id == $ppr.getLeft().getId() )
		)

		$pp2 :PatternPossibility(
			eval( id == $ppr.getRight().getId() )
		)
		
		# For every restriction in $pp1 there is a redundancy to $pp2. 
		forall(
			$r :Restriction(
				patternId == $pp1.patternId,
				this memberOf $pp1.items
			)
			
			Redundancy(
				(
					left == $r
					&&
					right memberOf $pp2.items
				) || (
					left memberOf $pp2.items
					&&
					right == $r
				)
			)
		)
		
		# For every restriction in $pp2 there is a redundancy to $pp1. 
		forall(
			$r :Restriction(
				patternId == $pp2.patternId,
				this memberOf $pp2.items
			)
			
			Redundancy(
				(
					left == $r
					&&
					right memberOf $pp1.items
				) || (
					left memberOf $pp1.items
					&&
					right == $r
				)
			)
		)
	then
		insert( new Redundancy( Redundancy.RedundancyType.STRONG, $pp1, $pp2 ) );
end

/*
rule "Find part of redundant RulePossibility combination"
	when
		# PatternPossibility Redundancy.
		$redundancy :Redundancy()
		
		# Check that rules are redundant.
		$r1 :AnalyticsRule()
		$r2 :AnalyticsRule( id != $r1.id )
		Redundancy( 
			left == $r1, 
			right == $r2 
		)
		
		# Find two RulePossibilities.
		$rp1 :RulePossibility( 
			ruleId == $r1.id,
			items contains $redundancy.left 
		)
		$rp2 :RulePossibility( 
			ruleId == $r2.id, 
			items contains $redundancy.right 
		)
		
		not PartialRedundancy(
			left == $rp1,
			right == $rp2
		)
	then
		insert( new PartialRedundancy( $rp1, $rp2, $redundancy ) );
end


rule "new rule"
	when
		$pr :PartialRedundancy()
		not PartialRedundancyCollection( 
			items contains $pr 
		)
		
		################################################
		# XXX: Database!
		################################################
	then
		insert( new PartialRedundancyCollection( $pr ) ); 
end

#
# Handles both RulePossibilities and PatternPossibilities.
#
rule "Find subsumptant Possibilities"
	when
		$p1 :Possibility()
		$p2 :Possibility( 
			id != $p1.id,
			amountOfItems >= $p1.amountOfItems
		)
		
		not Subsumption( 
				left == $p1, 
				right == $p2 
		)
		
		# At least one partial redundancy exists between these possibilities.
		exists( 
				PartialRedundancy( 
					left == $p1, 
					right == $p2 
				) 
		)
		
		# XXX: What if there is an earlier collection of these, so its only a == comparison.
		
		# Collect all the partial redundancies.
		#$list :ArrayList()
		#	from collect(
		#		PartialRedundancy( 
		#			left == $p1, 
		#			right == $p2 
		#		)
		#	)
			
		# If there as much partial redundancies as there is items in $p1,
		# then $p1 is subsumptant to $p2.
		#eval( $list.size() == $p1.getAmountOfItems() )
	then
		System.out.println( "Find subsumptant Possibilities" );
		#insert( new Subsumption( $p1, $p2 ) );
end


#
# If two possibilities are subsumptant to each others, then they are redundant.
# Since this tests only one possibility, the entire rule or pattern might not be redundant.
#
rule "Find redundant Possibilities"
	when
		$p1 :Possibility()
		$p2 :Possibility( id != $p1.id )
		
		not Redundancy( 
			left == $p1, 
			right == $p2 
		)
		
		not Redundancy( 
			left == $p2, 
			right == $p1 
		)
		
		Subsumption( 
				left == $p1, 
				right == $p2 
		)
		
		Subsumption( 
				left == $p2, 
				right == $p1 
		)
	then
		insert( new Redundancy( $p1, $p2 ) );
end
*/