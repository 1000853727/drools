package org.drools.reteoo;

/*
 * Copyright 2005 JBoss Inc
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.Iterator;

import org.drools.FactHandle;
import org.drools.WorkingMemory;
import org.drools.event.ActivationCancelledEvent;
import org.drools.event.ActivationCreatedEvent;
import org.drools.event.AfterActivationFiredEvent;
import org.drools.event.AgendaEventListener;
import org.drools.event.BeforeActivationFiredEvent;
import org.drools.event.ObjectAssertedEvent;
import org.drools.event.ObjectModifiedEvent;
import org.drools.event.ObjectRetractedEvent;
import org.drools.event.WorkingMemoryEventListener;
import org.drools.reteoo.event.ActivationLogEvent;
import org.drools.reteoo.event.LogEvent;
import org.drools.reteoo.event.ObjectLogEvent;
import org.drools.rule.Declaration;
import org.drools.spi.Activation;
import org.drools.spi.Tuple;

/**
 * A logger of events generated by a working memory.
 * It listens to the events generated by the working memory and
 * creates associated log event (containing a snapshot of the
 * state of the working event at that time).
 * 
 * Subclasses of this class should implement the logEventCreated(LogEvent)
 * method and store this information, like for example log to file
 * or database.
 * 
 * TODO: extend this class so filters can be used to specify which
 * events should be logged
 * 
 * @author <a href="mailto:kris_verlaenen@hotmail.com">Kris Verlaenen </a>
 */
public abstract class WorkingMemoryLogger implements WorkingMemoryEventListener, AgendaEventListener {

	/**
	 * Creates a new working memory logger for the given working memory.
	 * 
	 * @param workingMemory
	 */
	public WorkingMemoryLogger(WorkingMemory workingMemory) {
		workingMemory.addEventListener((WorkingMemoryEventListener) this);
		workingMemory.addEventListener((AgendaEventListener) this);
	}
	
	/**
	 * This method is invoked every time a new log event is created.
	 * Subclasses should implement this method and store the event,
	 * like for example log to a file or database.
	 * 
	 * @param logEvent
	 */
	public abstract void logEventCreated(LogEvent logEvent);
	
	/**
	 * @see org.drools.event.WorkingMemoryEventListener
	 */
	public void objectAsserted(ObjectAssertedEvent event) {
		logEventCreated(new ObjectLogEvent(
			LogEvent.OBJECT_ASSERTED,
			((FactHandleImpl) event.getFactHandle()).getId(), 
			event.getObject().toString()));
	}

	/**
	 * @see org.drools.event.WorkingMemoryEventListener
	 */
	public void objectModified(ObjectModifiedEvent event) {
		logEventCreated(new ObjectLogEvent(
			LogEvent.OBJECT_MODIFIED,
			((FactHandleImpl) event.getFactHandle()).getId(), 
			event.getObject().toString()));
	}

	/**
	 * @see org.drools.event.WorkingMemoryEventListener
	 */
	public void objectRetracted(ObjectRetractedEvent event) {
		logEventCreated(new ObjectLogEvent(
			LogEvent.OBJECT_RETRACTED,
			((FactHandleImpl) event.getFactHandle()).getId(), 
			event.getOldObject().toString()));
	}
	
	/**
	 * @see org.drools.event.AgendaEventListener
	 */
	public void activationCreated(ActivationCreatedEvent event) {
		logEventCreated(new ActivationLogEvent(
			LogEvent.ACTIVATION_CREATED,
			getActivationId(event.getActivation()),
			event.getActivation().getRule().getName(),
			extractDeclarations(event.getActivation())));
	}

	/**
	 * @see org.drools.event.AgendaEventListener
	 */
	public void activationCancelled(ActivationCancelledEvent event) {
		logEventCreated(new ActivationLogEvent(
			LogEvent.ACTIVATION_CANCELLED,
			getActivationId(event.getActivation()),
			event.getActivation().getRule().getName(),
			extractDeclarations(event.getActivation())));
	}

	/**
	 * @see org.drools.event.AgendaEventListener
	 */
	public void beforeActivationFired(BeforeActivationFiredEvent event) {
		logEventCreated(new ActivationLogEvent(
			LogEvent.BEFORE_ACTIVATION_FIRE,
			getActivationId(event.getActivation()),
			event.getActivation().getRule().getName(),
			extractDeclarations(event.getActivation())));
	}

	/**
	 * @see org.drools.event.AgendaEventListener
	 */
	public void afterActivationFired(AfterActivationFiredEvent event) {
		logEventCreated(new ActivationLogEvent(
			LogEvent.AFTER_ACTIVATION_FIRE,
			getActivationId(event.getActivation()),
			event.getActivation().getRule().getName(),
			extractDeclarations(event.getActivation())));
	}
	
	/**
	 * Creates a string representation of the declarations of an activation.
	 * This is a list of name-value-pairs for each of the declarations in the
	 * tuple of the activation.  The name is the identifier (=name) of the
	 * declaration, and the value is a toString of the value of the
	 * parameter, followed by the id of the fact between parentheses.
	 * 
	 * @param activation The activation from which the declarations should be extracted
	 * @return A String represetation of the declarations of the activation.
	 */
	private static String extractDeclarations(Activation activation) {
		StringBuffer result = new StringBuffer();
		Tuple tuple = activation.getTuple();
        Declaration[] declarations = activation.getRule().getDeclarations(); 
        for ( int i = 0, length = declarations.length; i < length; i++  ) {
			Declaration declaration = declarations[i];
			FactHandle handle = tuple.get(declaration);
			if (handle instanceof FactHandleImpl) {
				FactHandleImpl handleImpl = (FactHandleImpl) handle;
				Object value = handleImpl.getObject();
				result.append(declaration.getIdentifier());
				result.append("=");
				if (value == null) {
					// this should never occur
					result.append("null");
				} else {
					result.append(value);
					result.append("(");
					result.append(handleImpl.getId());
					result.append(")");
				}
			}
			if (i < declarations.length - 1) {
				result.append("; ");
			}
		}
		return result.toString();
	}
	
	/**
	 * Returns a String that can be used as unique identifier for an
	 * activation.  Since the activationId is the same for all assertions
	 * that are created during a single assert, modify or retract, the
	 * key of the tuple of the activation is added too (which is a set
	 * of fact handle ids). 
	 * 
	 * @param activation The activation for which a unique id should be generated
	 * @return A unique id for the activation
	 */
	private static String getActivationId(Activation activation) {
		StringBuffer result = new StringBuffer(activation.getRule().getName());
		result.append(" [");
		ReteTuple tuple = (ReteTuple) activation.getTuple();
		FactHandle[] handles = tuple.getKey().getFactHandles();
		for (int i = 0; i < handles.length; i++) {
			result.append(((FactHandleImpl) handles[i]).getId());
			if (i < handles.length - 1) {
				result.append(", ");
			}
		}
		return result.append("]").toString();
	}
}
