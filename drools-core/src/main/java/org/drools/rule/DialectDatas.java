package org.drools.rule;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

import org.drools.RuntimeDroolsException;
import org.drools.common.DroolsObjectInputStream;
import org.drools.rule.JavaDialectData.PackageClassLoader;

public class DialectDatas implements Externalizable {
    private ClassLoader parentClassLoader;
    private CompositePackageClassLoader classLoader;
    
    private Map<String, DialectData> dialects;
    
    private Map                           lineMappings;
    
    /**
     * Default constructor - for Externalizable. This should never be used by a user, as it
     * will result in an invalid state for the instance.
     */    
    public DialectDatas() {
        
    }
    
    public DialectDatas(ClassLoader classLoader) {
        this.parentClassLoader = classLoader;
        this.classLoader = new CompositePackageClassLoader( this.parentClassLoader );
        this.dialects = new HashMap<String, DialectData>();
    }
    
    /**
     * Handles the write serialization of the PackageCompilationData. Patterns in Rules may reference generated data which cannot be serialized by
     * default methods. The PackageCompilationData holds a reference to the generated bytecode. The generated bytecode must be restored before any Rules.
     *
     */
    public void writeExternal(final ObjectOutput stream) throws IOException {
        stream.writeObject( this.lineMappings );    
        
        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
        final ObjectOutput out = new ObjectOutputStream( bos );
        out.writeObject( this.dialects  );
        stream.writeObject( bos.toByteArray() );
    }

    /**
     * Handles the read serialization of the PackageCompilationData. Patterns in Rules may reference generated data which cannot be serialized by
     * default methods. The PackageCompilationData holds a reference to the generated bytecode; which must be restored before any Rules.
     * A custom ObjectInputStream, able to resolve classes against the bytecode, is used to restore the Rules.
     *
     */
    public void readExternal(final ObjectInput stream) throws IOException,
                                                      ClassNotFoundException {
        if ( stream instanceof DroolsObjectInputStream ) {
            DroolsObjectInputStream droolsStream = (DroolsObjectInputStream) stream;
            this.parentClassLoader = droolsStream.getClassLoader();
        } else {
            this.parentClassLoader = Thread.currentThread().getContextClassLoader();
        }
        
        this.classLoader = new CompositePackageClassLoader( this.parentClassLoader );

        this.lineMappings = (Map) stream.readObject();
        
        final byte[] bytes = (byte[]) stream.readObject();        
        final DroolsObjectInputStream streamWithLoader = new DroolsObjectInputStream( new ByteArrayInputStream( bytes ),
                                                                                      this.classLoader );
        streamWithLoader.setDialectDatas( this );
        this.dialects = (Map) streamWithLoader.readObject();
    }    
    
    public void addDialectData(String dialect, DialectData dialectData) {
        this.dialects.put( dialect, dialectData );
    }
    
    public void setDialectData(String name, DialectData data) {
        this.dialects.put( name, data );
    }
    
    public DialectData getDialectData(String dialect) {
        return this.dialects.get( dialect );
    }
    
    public DialectData removeRule(final Package pkg, final Rule rule) {
        DialectData dialect = this.dialects.get( rule.getDialect() );
        dialect.removeRule( pkg, rule );
        return dialect;
    }
    
    public DialectData removeFunction(final Package pkg, final Function function) {
        DialectData dialect = this.dialects.get( function.getDialect() );
        dialect.removeFunction( pkg, function );
        return dialect; 
    }
    
    public void merge(DialectDatas newDatas) {
        for(Iterator it = newDatas.dialects.entrySet().iterator(); it.hasNext(); ) {
            Entry entry = ( Entry ) it.next();
            DialectData data = ( DialectData ) this.dialects.get( entry.getKey() );
            data.merge( ( DialectData ) entry.getValue() ); 
        }
        
        if ( this.lineMappings != null ) {
            // merge line mappings
            this.lineMappings.putAll( newDatas.getLineMappings() );
        } else {
            this.lineMappings = newDatas.getLineMappings();
        }
    }
    
    public boolean isDirty() {
        return true;
    }
    
    public void reloadDirty() {
        // detect if any dialect is dirty, if so reload() them all
        boolean isDirty = false;
        for(Iterator it = this.dialects.values().iterator(); it.hasNext(); ) {            
            DialectData data = ( DialectData ) it.next();
            if ( data.isDirty() ) {
                isDirty = true;
                break;
            }
        }      
        
        if ( isDirty ) {
            this.classLoader = new CompositePackageClassLoader( this.parentClassLoader );
            for(Iterator it = this.dialects.values().iterator(); it.hasNext(); ) {            
                DialectData data = ( DialectData ) it.next();
                data.reload();
            }             
        }
    }       
    
    public ClassLoader getParentClassLoader() {
        return this.parentClassLoader;
    }

    public void setParentClassLoader(ClassLoader classLoader) {
        this.parentClassLoader = classLoader;
    }
    
    public ClassLoader getClassLoader() {
        return this.classLoader;
    }
    
    public void addClassLoader(ClassLoader classLoader) {
        this.classLoader.addClassLoader( classLoader );
    }

    public void clear() {
        this.dialects.clear();
    }
    
    public LineMappings getLineMappings(final String className) {
        return (LineMappings) getLineMappings().get( className );
    }    
    
    public Map getLineMappings() {
        if ( this.lineMappings == null ) {
            this.lineMappings = new HashMap();
        }
        return this.lineMappings;
    }    
}
