package org.drools.rule;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

import org.drools.common.DroolsObjectInput;

public class DialectDatas implements Externalizable {
    private transient ClassLoader parentClassLoader;
    private CompositePackageClassLoader classLoader;

    private Map<String, DialectData> dialects;

    private Map                           lineMappings;

    /**
     * Default constructor - for Externalizable. This should never be used by a user, as it
     * will result in an invalid state for the instance.
     */
    public DialectDatas() {
        this(null);
    }

    public DialectDatas(ClassLoader classLoader) {
        setParentClassLoader(classLoader);
        this.classLoader = new CompositePackageClassLoader( this.parentClassLoader );
        this.dialects = new HashMap<String, DialectData>();
    }

    /**
     * Handles the write serialization of the PackageCompilationData. Patterns in Rules may reference generated data which cannot be serialized by
     * default methods. The PackageCompilationData holds a reference to the generated bytecode. The generated bytecode must be restored before any Rules.
     *
     */
    public void writeExternal(final ObjectOutput stream) throws IOException {
        stream.writeObject(this.dialects);
        stream.writeObject( this.lineMappings );
    }

    /**
     * Handles the read serialization of the PackageCompilationData. Patterns in Rules may reference generated data which cannot be serialized by
     * default methods. The PackageCompilationData holds a reference to the generated bytecode; which must be restored before any Rules.
     * A custom ObjectInputStream, able to resolve classes against the bytecode, is used to restore the Rules.
     *
     */
    public void readExternal(final ObjectInput stream) throws IOException,
                                                              ClassNotFoundException {
        DroolsObjectInput   droolsStream    = (DroolsObjectInput)stream;

        setParentClassLoader(droolsStream.getClassLoader());
        this.classLoader = new CompositePackageClassLoader( this.parentClassLoader );
        droolsStream.setDialectDatas(this);
        droolsStream.setClassLoader(this.classLoader);

        this.dialects       = (Map<String, DialectData>)droolsStream.readObject();
        this.lineMappings   = (Map) stream.readObject();
    }

    public void addDialectData(String dialect, DialectData dialectData) {
        this.dialects.put( dialect, dialectData );
    }

    public void setDialectData(String name, DialectData data) {
        this.dialects.put( name, data );
    }

    public DialectData getDialectData(String dialect) {
        return this.dialects.get( dialect );
    }

    public DialectData removeRule(final Package pkg, final Rule rule) {
        DialectData dialect = this.dialects.get( rule.getDialect() );
        dialect.removeRule( pkg, rule );
        return dialect;
    }

    public DialectData removeFunction(final Package pkg, final Function function) {
        DialectData dialect = this.dialects.get( function.getDialect() );
        dialect.removeFunction( pkg, function );
        return dialect;
    }

    public void merge(DialectDatas newDatas) {
        for (Entry<String, DialectData> entry : newDatas.dialects.entrySet()) {
            DialectData data = this.dialects.get( entry.getKey() );
            if (data == null) {
                DialectData dialectData = entry.getValue().clone();
                dialectData.setDialectDatas(this);
                this.dialects.put(entry.getKey(), dialectData);
        } else {
                data.merge( entry.getValue() );
        }
    }

       getLineMappings().putAll(newDatas.getLineMappings());
    }

    public boolean isDirty() {
        return true;
    }

    public void reloadDirty() {
        // detect if any dialect is dirty, if so reload() them all
        boolean isDirty = false;
        for(Iterator it = this.dialects.values().iterator(); it.hasNext(); ) {
            DialectData data = ( DialectData ) it.next();
            if ( data.isDirty() ) {
                isDirty = true;
                break;
            }
        }

        if ( isDirty ) {
            this.classLoader = new CompositePackageClassLoader( this.parentClassLoader );
            for(Iterator it = this.dialects.values().iterator(); it.hasNext(); ) {
                DialectData data = ( DialectData ) it.next();
                data.reload();
            }
        }
    }

    public ClassLoader getParentClassLoader() {
        return this.parentClassLoader;
    }

    public void setParentClassLoader(ClassLoader classLoader) {
        if (classLoader == null) {
            classLoader = Thread.currentThread().getContextClassLoader();
            if ( classLoader == null ) {
                classLoader = getClass().getClassLoader();
            }
        }
        this.parentClassLoader = classLoader;
    }

    public ClassLoader getClassLoader() {
        return this.classLoader;
    }

    public void addClassLoader(ClassLoader classLoader) {
        this.classLoader.addClassLoader( classLoader );
    }

    public void removeClassLoader(ClassLoader classLoader) {
        if (classLoader != null) {
            this.classLoader.removeClassLoader(classLoader);
        }
    }

    public void clear() {
        this.dialects.clear();
    }

    public LineMappings getLineMappings(final String className) {
        return (LineMappings) getLineMappings().get( className );
    }

    public Map getLineMappings() {
        if ( this.lineMappings == null ) {
            this.lineMappings = new HashMap();
        }
        return this.lineMappings;
    }
}
